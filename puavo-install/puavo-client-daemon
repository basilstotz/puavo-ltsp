#!/usr/bin/ruby1.9.1

# Services activated by DBus service activation mechanism do not have
# all necessary components in PATH
ENV["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

require 'dbus'
require 'json'
require 'open3'
require 'puavo/rest-client'
require 'socket'
require 'syslog'

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end


$configuration_update_thread = nil
$image_update_thread         = nil

class CancelledImageUpdate < RuntimeError; end

class Updater < DBus::Object
  def configuration_update
    $configuration_update_thread = Thread.new do
      log(Syslog::LOG_INFO, "Starting configuration update\n")

      begin
	# Notify Puavo on our current image situation.  It is good to do this
	# on every image update, but also periodically, in case we have booted
	# to a new image (there might be a better place for this, but at least
	# the configuration update should be run periodically anyway).
        begin
          notify_puavo_on_images()
        rescue StandardError => e
          logerr(Syslog::LOG_WARNING,
                 "Could not update image information in Puavo: %s\n",
                 e.message)
        end

	command = '/usr/lib/puavo-ltsp-install/update-configuration'

	output, status = Open3.capture2e(command)
	if not status.success? then
	  logerr(Syslog::LOG_WARNING,
                 "Failed to update device configuration: %s\n",
                 output)
	end

	if !$image_update_thread then
	  system('/usr/lib/puavo-ltsp-install/is-update-available')
	  case $?.exitstatus
	    when 0
	      log(Syslog::LOG_INFO, "There is an update available\n")
	      self.UpdateAvailable
	    when 1
	      log(Syslog::LOG_INFO,
                  "System is up-to-date, no reboot required\n")
	      self.UpdateIsUpToDate(false) # false == no reboot required
	    when 2
	      log(Syslog::LOG_INFO,
                  "System is up-to-date, but reboot is required\n")
	      self.UpdateIsUpToDate(true)  # true == reboot *is* required
	    else
	      logerr(Syslog::LOG_ERR,
                     "Unknown exit code in is-update-available: %d\n",
                     $?.exitstatus)
	  end
	end
      rescue StandardError => e
        logerr(Syslog::LOG_ERR,
               "Could not do a configuration update: %s\n",
               e.message)
      ensure
	$configuration_update_thread = nil
      end
    end
  end

  def image_update(use_rate_limit, delete_overlays)
    $image_update_thread = Thread.new do
      wait_thr, out_thr, err_thr = nil, nil, nil

      begin
	if not system('/usr/lib/puavo-ltsp-install/is-update-available') then
          log(Syslog::LOG_INFO,
              "Checked for system update, but no update is available\n")
	  Thread.exit
	end

        log(Syslog::LOG_INFO, "Starting system update\n")
	self.UpdateStarted

	stdin, stdout, stderr, wait_thr \
	  = Open3.popen3('/usr/lib/puavo-ltsp-install/update-images',
			 use_rate_limit  ? 'true' : 'false',
			 delete_overlays ? 'true' : 'false',
			 { :pgroup => true })

	stdin.close
	out_thr = Thread.new do
	  loop { self.UpdateMessage('ok', stdout.readline) } \
	    rescue EOFError
        end
	err_thr = Thread.new do
	  loop { self.UpdateMessage('error', stderr.readline) } \
	    rescue EOFError
	end

	status = wait_thr.value

	[ out_thr, err_thr ].each { |t| t.join if t }

	if not status.success? then
	  self.UpdateFailed
	  raise 'Failed to update system, update-images returned ' \
                  + status.exitstatus.to_s
	end

        log(Syslog::LOG_INFO, "System update completed\n")
	self.UpdateCompleted

	# update device information in Puavo and in local disk as well
	confthread = $configuration_update_thread
        if confthread then
          log(Syslog::LOG_DEBUG,
              "Configuration update in progress, waiting for it to finish\n")
	  confthread.join
        end
        log(Syslog::LOG_INFO,
            "Starting post-system-update configuration update\n")
	configuration_update().join

      rescue CancelledImageUpdate => e
	if wait_thr then
	  if wait_thr.alive? then
	    Process.kill('-TERM', wait_thr.pid)
	  end
	  wait_thr.join

	  [ out_thr, err_thr ].each { |t| t.join if t }
	end

        logerr(Syslog::LOG_WARNING, "System update was cancelled\n")
	self.UpdateCancelled

      rescue StandardError => e
        logerr(Syslog::LOG_ERR,
               "Error occurred when doing system update: %s\n",
               e.message)
      ensure
	[ out_thr, err_thr ].each { |t| t.exit if t }
	$image_update_thread = nil
      end
    end
  end

  def notify_puavo_on_images
    available_images \
      = (Dir.glob('/images/*.img').map { |p| File.basename(p) } \
	   - %w(ltsp.img ltsp-backup.img)).sort
    current_image = IO.readlines('/etc/ltsp/this_ltspimage_name') \
		      .first.chomp

    deviceinfo = JSON.parse( File.read('/state/etc/puavo/device.json') )

    update_available_images \
      = ((deviceinfo['available_images'] || []).sort != available_images)
    update_current_image = (deviceinfo['current_image'] != current_image)

    if update_available_images || update_current_image then
      if update_available_images then
        log(Syslog::LOG_NOTICE, "Updating available images in Puavo\n")
      end
      if update_current_image then
        log(Syslog::LOG_NOTICE, "Updating the current image in Puavo\n")
      end

      # Set :dns => :no because we write stuff to Puavo and we have much
      # better chances of finding the right server when not using DNS.
      client = PuavoRestClient.new(:auth => :etc, :dns => :no)

      restpath = "/v3/devices/#{ Socket.gethostname }"
      senddata = {
	'available_images' => available_images,
	'current_image'    => current_image,
      }
      client.post(restpath, :json => senddata)
    end
  end

  dbus_interface "org.puavo.client.update" do
    dbus_signal :UpdateAvailable
    dbus_signal :UpdateCancelled
    dbus_signal :UpdateCompleted
    dbus_signal :UpdateFailed
    dbus_signal :UpdateIsUpToDate,        'in reboot_required:b'
    dbus_signal :UpdateMessage,           'in msgtype:s, in content:s'
    dbus_signal :UpdateProgressIndicator, 'in phase:s, in progress:i'
    dbus_signal :UpdateStarted

    dbus_method :CancelImageUpdate, '' do
      if $image_update_thread then
        $image_update_thread.raise(CancelledImageUpdate, 'Cancel image update')
      else
        self.UpdateCancelled
      end
    end

    dbus_method :HasOldOverlays, 'out b' do
      begin
        output, errput, status \
          = Open3.capture3('/usr/lib/puavo-ltsp-install/ls-old-imageoverlays',
                           '/images',
                           '/imageoverlays')
        if not status.success? then
          errmsg = 'Failed to list old overlays: error code ' \
                     + "#{ status.exitstatus } / #{ errput }"
          raise errmsg
        end

        return !output.empty?
      rescue StandardError => e
        logerr(Syslog::LOG_ERR, "%s\n", e.message)
        raise e
      end
    end

    dbus_method :Update,
                'in use_rate_limit:b, in delete_overlays:b, out b' do
      |use_rate_limit, delete_overlays|
        Thread.new do
          ($configuration_update_thread || self.configuration_update()) \
            .join
          ($image_update_thread || self.image_update(use_rate_limit,
                                                     delete_overlays)) \
            .join
        end
    end

    dbus_method :UpdateConfiguration, 'out b' do
      self.configuration_update() unless $configuration_update_thread
    end

    dbus_method :UpdateProgress,
                "in phase:s, in progress:i" do |phase, progress|
      self.UpdateProgressIndicator(phase, progress)
    end
  end

end

Syslog.open(File.basename($0), Syslog::LOG_CONS)

bus = DBus::SystemBus.instance

# Request a well-known name for the service. It can be denied if someone
# has reserved the name (very unlikely, only if someone is playing
# tricks with us) or we do not have permissions to own the name (missing
# conf file in /etc/dbus-1/system.d).
service = bus.request_service("org.puavo.client.Daemon")

# Export all dbus-accessible objects. Currently we have only one, but
# there isn't any reason why we wouldn't them more in future.
updater = Updater.new("/updater")
service.export(updater)

# Run Forrest, run!
loop = DBus::Main.new
loop << bus
loop.run

Syslog.close()
