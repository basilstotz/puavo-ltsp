#!/usr/bin/ruby1.9.1

# Services activated by DBus service activation mechanism do not have
# all necessary components in PATH
ENV["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

require 'dbus'
require 'open3'
require 'puavo/rest-client'
require 'socket'

$configuration_update_thread   = nil
$image_update_thread           = nil
$notify_puavo_on_images_thread = nil

class CancelledImageUpdate < RuntimeError; end

class Updater < DBus::Object
  def configuration_update
    $configuration_update_thread = Thread.new do
      begin
	command = '/usr/lib/puavo-ltsp-install/update-configuration'

	output, status = Open3.capture2e(command)
	if not status.success? then
	  raise "failed to update device configuration: #{ output }"
	end

	if !$image_update_thread then
	  system('/usr/lib/puavo-ltsp-install/is-update-available')
	  case $?.exitstatus
	    when 0
	      self.UpdateAvailable
	    when 1
	      self.UpdateIsUpToDate(false) # no reboot required
	    when 2
	      self.UpdateIsUpToDate(true)  # reboot *is* required
	  end
	end

	# Notify Puavo on our current image situation.  It is good to do this
	# on every image update, but also periodically, in case we have booted
	# to a new image (there might be a better place for this, but at least
	# the configuration update should be run periodically anyway).
	notify_puavo_on_images()
      ensure
	$configuration_update_thread = nil
      end
    end
  end

  def image_update(use_rate_limit, delete_overlays)
    $image_update_thread = Thread.new do
      wait_thr, out_thr, err_thr = nil, nil, nil

      begin
	if not system('/usr/lib/puavo-ltsp-install/is-update-available') then
	  Thread.exit
	end

	self.UpdateStarted

	stdin, stdout, stderr, wait_thr \
	  = Open3.popen3('/usr/lib/puavo-ltsp-install/update-images',
			 use_rate_limit  ? 'true' : 'false',
			 delete_overlays ? 'true' : 'false',
			 { :pgroup => true })

	stdin.close
	out_thr = Thread.new do
	  loop { self.UpdateMessage('ok', stdout.readline) } \
	    rescue EOFError
        end
	err_thr = Thread.new do
	  loop { self.UpdateMessage('error', stderr.readline) } \
	    rescue EOFError
	end

	status = wait_thr.value

	[ out_thr, err_thr ].each { |t| t.join if t }

	if not status.success? then
	  self.UpdateFailed
	  raise "Failed to update device images"
	end
	self.UpdateCompleted

	notify_puavo_on_images()

      rescue CancelledImageUpdate => e
	if wait_thr then
	  if wait_thr.alive? then
	    Process.kill('-TERM', wait_thr.pid)
	  end
	  wait_thr.join

	  [ out_thr, err_thr ].each { |t| t.join if t }
	end

	self.UpdateCancelled

      ensure
	[ out_thr, err_thr ].each { |t| t.exit if t }
	$image_update_thread = nil
      end
    end
  end

  def notify_puavo_on_images
    Thread.kill($notify_puavo_on_images_thread) \
      if $notify_puavo_on_images_thread

    $notify_puavo_on_images_thread = Thread.new do
      begin
	available_images \
	  = (Dir.glob('/images/*.img').map { |p| File.basename(p) } \
	       - %w(ltsp.img ltsp-backup.img)).sort
	current_image = IO.readlines('/etc/ltsp/this_ltspimage_name') \
			  .first.chomp

	hostname = Socket.gethostname

	# Set :dns => :no because we write stuff to Puavo and we have much
	# better chances of finding the right server when not using DNS.
	client = PuavoRestClient.new(:auth => :etc, :dns => :no)

	restpath = "/v3/devices/#{ hostname }"

	gres = client.get(restpath)
	raise "Response code for get-request was: #{ gres.code }" \
	  unless gres.code == 200
	deviceinfo = gres.parse()

	update_available_images \
	  = ((deviceinfo['available_images'] || []).sort != available_images)
	update_current_image = (deviceinfo['current_image'] != current_image)

	puts 'Updating available images in Puavo'  if update_available_images
	puts 'Updating the current image in Puavo' if update_current_image

	if update_available_images || update_current_image then
	  senddata = {
	    'available_images' => available_images,
	    'current_image'    => current_image,
	  }
	  pres = client.post(restpath, :json => senddata)
	  raise "Response code for post-request was: #{ pres.code }" \
	    unless pres.code == 200
	end

      rescue StandardError => e
	raise "Could not update image information in Puavo: '#{ e.message }'"

      ensure
	$notify_puavo_on_images_thread = nil
      end
    end
  end

  dbus_interface "org.puavo.client.update" do
    dbus_signal :UpdateAvailable
    dbus_signal :UpdateCancelled
    dbus_signal :UpdateCompleted
    dbus_signal :UpdateFailed
    dbus_signal :UpdateIsUpToDate,        'in reboot_required:b'
    dbus_signal :UpdateMessage,           'in msgtype:s, in content:s'
    dbus_signal :UpdateProgressIndicator, 'in phase:s, in progress:i'
    dbus_signal :UpdateStarted

    dbus_method :CancelImageUpdate, '' do
      if $image_update_thread then
        $image_update_thread.raise(CancelledImageUpdate, 'Cancel image update')
      else
        self.UpdateCancelled
      end
    end

    dbus_method :HasOldOverlays, 'out b' do
      output, errput, status \
        = Open3.capture3('/usr/lib/puavo-ltsp-install/ls-old-imageoverlays',
                         '/images',
                         '/imageoverlays')
      if not status.success? then
        raise "failed to list old overlays: #{ errput }"
      end
      return !output.empty?
    end

    dbus_method :Update,
                'in use_rate_limit:b, in delete_overlays:b, out b' do
      |use_rate_limit, delete_overlays|
        Thread.new do
          ($configuration_update_thread || self.configuration_update()) \
            .join
          ($image_update_thread || self.image_update(use_rate_limit,
                                                     delete_overlays)) \
            .join
        end
    end

    dbus_method :UpdateConfiguration, 'out b' do
      self.configuration_update() unless $configuration_update_thread
    end

    dbus_method :UpdateProgress,
                "in phase:s, in progress:i" do |phase, progress|
      self.UpdateProgressIndicator(phase, progress)
    end
  end

end

bus = DBus::SystemBus.instance

# Request a well-known name for the service. It can be denied if someone
# has reserved the name (very unlikely, only if someone is playing
# tricks with us) or we do not have permissions to own the name (missing
# conf file in /etc/dbus-1/system.d).
service = bus.request_service("org.puavo.client.Daemon")

# Export all dbus-accessible objects. Currently we have only one, but
# there isn't any reason why we wouldn't them more in future.
updater = Updater.new("/updater")
service.export(updater)

# Run Forrest, run!
loop = DBus::Main.new
loop << bus
loop.run
