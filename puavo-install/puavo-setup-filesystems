#!/usr/bin/ruby
#
# Setup local filesystems for Puavo hosts

require 'fileutils'
require 'highline/import'
require 'open3'

# XXX this should be elsewhere, other scripts might find this useful
module PuavoFacts
  Puavodir = '/etc/puavo'

  FactPaths = {
		'kerberos_master'   => 'kerberos/master',
		'kerberos_realm'    => 'kerberos/realm',
		'kerberos_toprealm' => 'kerberos/toprealm',
		'ldap_base'         => 'ldap/base',
		'ldap_binddn'       => 'ldap/dn',
		'ldap_bindpw'       => 'ldap/password',
		'ldap_master'       => 'ldap/master',
		'puavo_domain'      => 'domain',
		'puavo_hostname'    => 'hostname',
		'puavo_hosttype'    => 'hosttype',
		'puavo_topdomain'   => 'topdomain',
	      }

  def self.all
    Hash[ FactPaths.map { |name, path| [ name, get(name) ] } ]
  end

  def self.get(name)
    File.read("#{ Puavodir }/#{ FactPaths[ name ] }").chomp \
      or raise "Could not read a fact '#{ name }'"
  end
end

module DiskHandler
  Filesystems = {
    'laptop' => [
      { 'size' => '4G',       'name' => 'swap',   'type' => 'swap' },
      { 'size' => '6G',       'name' => 'tmp',    'type' => 'ext4' },
      { 'size' => '40G',      'name' => 'images', 'type' => 'ext4' },
      { 'size' => '4G',       'name' => 'state',  'type' => 'ext4' },
      { 'size' => '100%FREE', 'name' => 'home',   'type' => 'ext4' },
    ],
    'ltspserver' => [
      { 'size' => '16G',      'name' => 'swap',   'type' => 'swap' },
      { 'size' => '6G',       'name' => 'tmp',    'type' => 'ext4' },
      { 'size' => '100%FREE', 'name' => 'state',  'type' => 'ext4' },
    ],
    'wirelessaccesspoint' => [
      { 'size' => '2G',       'name' => 'swap',   'type' => 'swap' },
      { 'size' => '3G',       'name' => 'tmp',    'type' => 'ext4' },
      { 'size' => '2G',       'name' => 'state',  'type' => 'ext4' },
      { 'size' => '100%FREE', 'name' => 'images', 'type' => 'ext4' },
    ],
  }

  def self.cleanup_disk_environment(hosttype)
    # Unmount filesystems, if those are mounted.
    non_swap_filesystems(hosttype).each do |fs|
      run('umount', '-f', "/#{ fs['name'] }") rescue true
    end

    # turn off swap partitions
    run('swapoff', '-a') rescue true

    # Remove dmsetup volumes as well, in case these are effective.
    run('dmsetup', 'remove_all', '--force') rescue true

    # switch off all volume groups that may interfere with following operations
    run('vgchange', '-a', 'n') rescue true
  end

  def self.do_fs_setup(conf)
    fs_conf = conf.clone

    fs_setup_phases = []

    if fs_conf['partition'] == 'whole'
      fs_setup_phases += [ :lvm_partition, :puavo_filesystems ]
      fs_conf['partition'] = "#{ fs_conf['device'] }1"
    else
      fs_setup_phases += [ :puavo_filesystems ]
    end

    fs_setup_phases += [ :mount_filesystems ]

    fs_conf.merge!({ 'device'    => "/dev/#{ fs_conf['device'   ] }",
		     'partition' => "/dev/#{ fs_conf['partition'] }" })

    fs_setup_phases.each do |fn_sym|
      method(fn_sym).call(fs_conf)
    end
  end

  def self.run(*cmd)
    system(*cmd) or raise "Error running command: '#{ cmd.inspect }'"
  end

  def self.lvm_partition(fs_conf)
    # clean up possible confusing mess from the device
    run('dd', 'if=/dev/zero', "of=#{ fs_conf['device'] }", 'count=2K')

    # create an lvm partition
    # see http://www.walkernews.net/2007/07/02/how-to-create-linux-lvm-in-3-minutes/
    IO.popen("fdisk #{ fs_conf['device'] }", 'w') do |f|
      f.print "n\np\n1\n#{ fs_conf['first_sector'] }\n#{ fs_conf['last_sector'] }\nt\n8e\na\n1\np\nw\n"
    end
  end

  def self.non_swap_filesystems(hosttype)
    Filesystems[ hosttype ] \
      .select { |fs| fs['type'] != 'swap' }
  end

  def self.puavo_filesystems(fs_conf)
    # clean up possible confusing mess from the partition
    run('dd', 'if=/dev/zero', "of=#{ fs_conf['partition'] }", 'count=1K')

    # create LVM volume groups
    run('pvcreate', fs_conf['partition'])
    run('vgcreate', '-s', '64M', 'puavo', fs_conf['partition'])

    Filesystems[ fs_conf['hosttype'] ].each do |fs|
      mkfs(fs['size'], fs['name'], fs['type'])
    end
  end

  def self.mkfs(size, name, type)
    run('lvcreate',
	(size.match(/%/) ? '-l' : '-L'), size,
	'-n', name,
	'puavo')

    case type
      when 'ext4'
        run('mkfs.ext4', '-v', "/dev/mapper/puavo-#{ name }")
      when 'swap'
        run('mkswap',    '-f', "/dev/mapper/puavo-#{ name }")
    end
  end

  def self.mount_filesystems(fs_conf)
    non_swap_filesystems( fs_conf['hosttype'] ).each do |fs|
      mnt_path = "/#{ fs['name'] }"
      FileUtils.mkdir_p(mnt_path)
      run('mount', "/dev/mapper/puavo-#{ fs['name'] }", mnt_path)
    end
  end
end

module QueryDiskInfo
  def self.ask_device()
    disk_devices = []

    chosen_disk_device = nil
    until disk_devices.include?(chosen_disk_device) do
      disk_devices = IO.readlines('/proc/partitions') \
                     .map { |s| s.split(' ')[3] }     \
                     .select { |s| s && s.match(/^[vs]d[a-z]$/) }

      puts '-----'
      puts "This machine has the following disk devices:\n"
      show_disk_devices(disk_devices)

      if chosen_disk_device.nil?
        chosen_disk_device = disk_devices[0]
      end

      puts "\nPossible disk devices are: #{ disk_devices.join(' ') }"
      chosen_disk_device = UI::ask_with_default('Choose a disk device:',
					        chosen_disk_device)
    end

    chosen_disk_device
  end

  def self.ask_confirmation(device, partition)
    if device.nil? || device.empty? || partition.nil? || partition.empty?
      return false
    end

    puts %Q{\nYou are going to install to device "/dev/#{ device }", } \
	 + %Q{partition "#{ partition }".}
    UI::colormsg("IF YOU PROCEED, ALL DATA ON THAT PARTITION IS DESTROYED!\n",
		 HighLine::RED)

    prompt = %q{Are you sure you want to proceed (write "yes" if this is okay?)}

    UI::ask_with_default(prompt, 'no') == 'yes'
  end

  UNIT_BYTES = {
    'K' => 1024 ** 1,
    'M' => 1024 ** 2,
    'G' => 1024 ** 3,
  }

  def self.ask_last_sector(device, first_sector)
    device_basename = File.basename(device)
    sectors = File.read("/sys/block/#{device_basename}/size").strip().to_i()
    sector_bytes = File.read("/sys/block/#{device_basename}/queue/logical_block_size").strip().to_i()

    while true do
      tailroom_str = UI::ask_with_default('How much unpartitioned space '\
                                          'should be left to the end of '\
                                          'the device:', '0G')

      # Parse and check the unit.
      tailroom_unit = tailroom_str[-1]
      if not UNIT_BYTES.include?(tailroom_unit)
        UI::colormsg("Invalid unit, available units: #{UNIT_BYTES.keys}.",
                     HighLine::RED)
        next
      end
      unit_bytes = UNIT_BYTES[tailroom_unit]

      # Parse and check the value.
      tailroom_value_str = tailroom_str[0..-2]
      begin
        tailroom_value = Integer(tailroom_value_str)
      rescue ArgumentError
        UI::colormsg("Invalid number '#{tailroom_value_str}', expected a non-negative integer.",
                     HighLine::RED)
        next
      end
      if tailroom_value < 0
        UI::colormsg("Invalid number '#{tailroom_value_str}', expected a non-negative integer.",
                     HighLine::RED)
        next
      end

      # Convert value to sectors.
      tailroom_bytes = tailroom_value * unit_bytes
      tailroom_sectors = tailroom_bytes / sector_bytes
      if tailroom_sectors > sectors - first_sector
        UI::colormsg("The size of the tailroom exceeds the size of the device.",
                     HighLine::RED)
        next
      end

      last_sector = sectors - tailroom_sectors - 1
      break

    end
    last_sector
  end

  def self.ask_device_and_partition_with_confirmation(hosttype)
    do_it = false
    device    = nil
    partition = nil
    first_sector = nil
    last_sector = nil

    until do_it do
      device    = QueryDiskInfo::ask_device()
      partition = QueryDiskInfo::ask_partition(device)
      if partition == 'whole'
        first_sector = 2048
        last_sector = QueryDiskInfo::ask_last_sector(device, first_sector)
      end

      do_it = QueryDiskInfo::ask_confirmation(device, partition)
    end

    {
      'device'    => device,
      'first_sector' => first_sector,
      'hosttype'  => hosttype,
      'last_sector' => last_sector,
      'partition' => partition,
    }
  end

  def self.ask_partition(disk_device)
    partitions = []

    chosen_partition = 'whole'
    until partitions.include?(chosen_partition) do
      if chosen_partition == 'fdisk'
        system('fdisk', "/dev/#{ disk_device }")
        chosen_partition = 'whole'
      end

      puts '-----'
      puts "The disk /dev/#{ disk_device } has the following partitions:\n"
      show_disk_devices(disk_device)

      partitions \
        = %w(whole) \
          + IO.readlines('/proc/partitions') \
              .map { |line| (line.split)[3] } \
              .compact \
              .select { |part| part.match(/^#{ disk_device }[0-9]/) } \

      puts "\nPossible partitions are: #{ partitions.join(' ') }"
      puts "\nYou may choose 'fdisk' to partition this disk,"
      puts "or choose 'whole' to use the whole disk.\n"
      chosen_partition = UI::ask_with_default('Choose a partition:',
					     chosen_partition)
    end
    chosen_partition
  end

  def self.show_disk_devices(disk_devices)
    sleep(1.5)
    [ disk_devices ].each do |device|
      system("fdisk -l /dev/#{ device } | more") \
        or raise "Error running fdisk for device '#{ device }'"
    end
  end
end

# XXX could be shared with puavo-register
module UI
  def self.ask_with_default(question, default)
    prompt = "#{ question } [#{ default }] "
    answer = HighLine.ask(prompt) { |q| q.whitespace = nil }

    return answer.match(/^\n$/)  ? default \
         : answer.match(/^\s+$/) ? ''      \
         : answer.strip
  end

  def self.colormsg(msg, color)
    HighLine.say(HighLine.new.color(msg, color))
  end
end

hosttype = PuavoFacts::get('puavo_hosttype')

DiskHandler::cleanup_disk_environment(hosttype)

case hosttype
  when 'laptop', 'ltspserver', 'wirelessaccesspoint'
    conf = QueryDiskInfo::ask_device_and_partition_with_confirmation(hosttype)
    DiskHandler::do_fs_setup(conf)
  else
    puts "Hosttype '#{ hosttype }' does not need to setup local filesystems."
end
