#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import datetime
import gettext
gettext.bindtextdomain('puavo-client-updater-applet', '/usr/share/locale')
gettext.textdomain('puavo-client-updater-applet')
_tr = gettext.gettext

import appindicator
import dbus
import dbus.mainloop.glib
import grp
import gtk
import os
import pwd
import pynotify
import re
import sys

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

def is_on_persistent_overlay():
    file = open('/proc/cmdline', 'r')
    cmdline = file.read()
    file.close()
    return re.match(".*?puavo.image.overlay=", cmdline)


class UpdateIndicatorApplet:
    def __init__(self):
        self.indicator \
          = appindicator.Indicator('update-indicator',
                                   'update-idle',
                                   appindicator.CATEGORY_APPLICATION_STATUS)
        self.indicator.set_status(appindicator.STATUS_ACTIVE)

        menu = gtk.Menu()

        if is_on_persistent_overlay():
            self.add_disabled_widget(menu)
	    self.indicator.set_menu(menu)
            return

        pynotify.init('puavo-client-updater-applet')
        self.available_notice_shown = False
        self.download_animation_icons \
          = [ 'update-downloading' ] \
              + [ 'update-downloading-%02d' % x for x in range(2, 14) ]

        self.add_update_button(menu)
        self.add_view_log_button(menu)
        self.add_progress(menu)

        self.connect_to_dbus()
        self.setup_log()
        self.setup_delete_overlays_dialog()

        self.indicator.set_menu(menu)


    def add_disabled_widget(self, menu):
	msg = _tr('Updates are disabled in developer mode, boot to normal mode to update.')
	self.disabled_msg = gtk.MenuItem(msg)
	self.disabled_msg.set_sensitive(False)
	self.disabled_msg.show()

	menu.append(self.disabled_msg)


    def add_progress(self, menu):
        self.progress = gtk.MenuItem('')
        self.set_progress_text( _tr('(No update progress.)') )
        self.progress.set_sensitive(False)
        self.progress.show()

        menu.append(self.progress)


    def add_update_button(self, menu):
        self.update_button = gtk.MenuItem('')
        self.button_action_handler = None
        self.set_update_button_mode('check')
        self.update_button.show()

        menu.append(self.update_button)


    def add_view_log_button(self, menu):
        self.view_log_item = gtk.MenuItem( _tr('View log...') )
        self.view_log_item.connect('activate', self.view_log)
        self.view_log_item.show()

        menu.append(self.view_log_item)


    def append_error_to_log(self, errortext):
        self.append_text_to_log(errortext, True)


    def append_text_to_log(self, text, error=False):
        if text == '':
            return

        end_iter = self.log_buffer.get_end_iter()

        timestamped_text = re.sub(r'^',
                                  '%s: ' % datetime.datetime.now(),
                                  text.rstrip(),
                                  flags=re.MULTILINE) \
                             + "\n"

        if not error:
            self.log_buffer.insert_with_tags(end_iter, timestamped_text)
            print(timestamped_text, end='')
        else:
            self.log_buffer.insert_with_tags(end_iter,
                                             timestamped_text,
                                             self.log_error_tag)
            print(timestamped_text, file=sys.stderr, end='')



    def cancel_image_update(self, widget):
        self.update_iface.CancelImageUpdate()


    def check_for_updates(self, widget):
        self.set_update_button_mode('checking')

        self.update_iface \
            .UpdateConfiguration(reply_handler=self.append_text_to_log,
                                 error_handler=self.append_error_to_log)


    def connect_to_dbus(self):
        self.bus = dbus.SystemBus()
        updater = self.bus.get_object('org.puavo.client.Daemon', '/updater')
        self.update_iface = dbus.Interface(updater,
                                           dbus_interface='org.puavo.client.update')
        self.update_iface.connect_to_signal('UpdateIsUpToDate',
                                            self.on_update_isuptodate)
        self.update_iface.connect_to_signal('UpdateAvailable',
                                            self.on_update_available)
        self.update_iface.connect_to_signal('UpdateStarted',
                                            self.on_update_started)
        self.update_iface.connect_to_signal('UpdateProgressIndicator',
                                            self.on_update_progress_indicator)
        self.update_iface.connect_to_signal("UpdateCancelled",
                                            self.on_update_cancelled)
        self.update_iface.connect_to_signal('UpdateFailed',
                                            self.on_update_failed)
        self.update_iface.connect_to_signal('UpdateCompleted',
                                            self.on_update_completed)


    def notify(self, msg):
        pynotify.Notification(msg).show()


    def on_update_available(self):
        self.set_update_button_mode('update')

        self.indicator.set_attention_icon('update-available')
        self.indicator.set_status(appindicator.STATUS_ATTENTION)

        # show only once after each login
        if not self.available_notice_shown:
            self.notify( _tr('A new system update is available.') )
            self.available_notice_shown = True


    def on_update_cancelled(self, outmsg, errmsg):
        self.on_update_progress_indicator('interrupted')
        self.on_update_available()

        self.append_text_to_log( _tr('Update cancelled.') + "\n" )
        self.append_text_to_log(outmsg)
        self.append_error_to_log(errmsg)

        self.notify( _tr('System update has been cancelled.') )


    def on_update_completed(self, outmsg, errmsg):
        self.set_update_button_mode('check')

        self.on_update_isuptodate(True)

        self.append_text_to_log( _tr('Update completed.') + "\n" )
        self.append_text_to_log(outmsg)
        self.append_error_to_log(errmsg)

        self.available_notice_shown = False
        self.notify( _tr('System update is finished, reboot the computer.') )


    def on_update_failed(self, outmsg, errmsg):
        self.set_update_button_mode('update')

        self.indicator.set_attention_icon('update-error')
        self.indicator.set_status(appindicator.STATUS_ATTENTION)

        self.append_text_to_log( _tr('Update failed.') + "\n" )
        self.append_text_to_log(outmsg)
        self.append_error_to_log(errmsg)

        self.notify( _tr('An error occurred when updating the system.') )


    def on_update_isuptodate(self, reboot_required):
        if reboot_required:
            self.on_update_progress_indicator('finished')
            self.indicator.set_attention_icon('update-installed')
            self.indicator.set_status(appindicator.STATUS_ATTENTION)
        else:
            self.on_update_progress_indicator('uptodate')
            self.indicator.set_icon('update-idle')
            self.indicator.set_status(appindicator.STATUS_ACTIVE)


    def on_update_progress_indicator(self, phase, progress=0):
        mode, text = None, None

        if phase == 'error':
            mode = 'update'
            text = _tr('Update failed.')
        elif phase == 'finished':
            mode = 'check'
            text = _tr('Update done, reboot required to finish the update.')
        elif phase == 'interrupted':
            mode = 'update'
            text = _tr('Update interrupted.')
        elif phase == 'uptodate':
            mode = 'check'
            text = _tr('Up to date.')

        if mode and text:
            self.set_progress_text(text)
            self.set_update_button_mode(mode)
            return

	# It might be strange to have phase 2 two times, but image_download
	# and rdiff_fetch/rdiff_checksum/image_patch are alternative routes
	# to the same result.
        phases = {
          'starting':        '0',
          'checksums_fetch': '1',
          'image_download':  '2',
          'rdiff_fetch':     '2',
          'rdiff_checksum':  '3',
          'image_patch':     '4',
          'image_checksum':  '5',
        }

        try:
            phase_number = phases[phase]
        except KeyError:
            phase_number = '?'

        text = '%s (%s/5) %s%%' \
                 % (_tr('Update progress:'), phase_number, progress)

        self.set_progress_text(text)
        self.set_update_button_mode('updating')

        self.indicator.set_attention_icon(self.download_animation_icons[0])
        self.indicator.set_status(appindicator.STATUS_ATTENTION)

        # cycle attention icons
        self.download_animation_icons \
          = self.download_animation_icons[1:] \
              + [ self.download_animation_icons[0] ]



    def on_update_started(self):
        self.set_update_button_mode('updating')
        self.indicator.set_attention_icon('update-downloading')
        self.indicator.set_status(appindicator.STATUS_ATTENTION)

        self.notify( _tr('System update has been started.') )


    def set_progress_text(self, text):
        wrapped_text = '-=> ' + text + ' <=-'
        self.progress.get_child().set_text(wrapped_text)


    def set_update_button_mode(self, mode):
        action = None

        if mode == 'check':
            action      = self.check_for_updates
            message     = _tr('Check for updates')
            sensitivity = True
        elif mode == 'checking':
            message     = _tr('(Checking for updates.)')
            sensitivity = False
        elif mode == 'update':
            action      = self.update_image
            message     = _tr('Update')
            sensitivity = True
        elif mode == 'updating':
            message     =_tr('Cancel update')
            action      = self.cancel_image_update
            sensitivity = True
        else:
            raise Exception('Wrong arguments for set_update_button_mode')

        if self.button_action_handler:
            self.update_button.disconnect(self.button_action_handler)
            self.button_action_handler = None
        if action:
            self.button_action_handler \
              = self.update_button.connect('activate', action)

        self.update_button.get_child().set_text(message)
        self.update_button.set_sensitive(sensitivity)


    def setup_delete_overlays_dialog(self):
        delete_overlays_message \
          = _tr('The old version of the system has been edited '
                'by the user. Updating the system causes '
                'all these changes to be lost. '
                'Do you want to proceed?')

        self.delete_overlays_dialog \
          = gtk.MessageDialog(None,
                              gtk.DIALOG_MODAL,
                              gtk.MESSAGE_QUESTION,
                              gtk.BUTTONS_YES_NO,
                              delete_overlays_message)

        self.delete_overlays_dialog.set_title( _tr('Continue updating?') )


    def setup_log(self):
        self.log_dialog \
          = gtk.Dialog(title=_tr('Update log'),
                       parent=None,
                       flags=gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                       buttons=(gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))

        self.log_dialog.set_default_size(600, 300)
        self.log_buffer = gtk.TextBuffer()
        self.log_error_tag = self.log_buffer.create_tag(foreground='red',
                                                        left_margin=20)

        self.log_view = gtk.TextView(self.log_buffer)
        self.log_view.set_editable(False)
        self.log_view.set_cursor_visible(False)
        self.log_view.show()

        log_scroll = gtk.ScrolledWindow()
        log_scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        log_scroll.add(self.log_view)
        log_scroll.show()

        self.log_dialog.vbox.pack_start(log_scroll)


    def update_image(self, widget):
        delete_overlays = False

        if self.update_iface.HasOldOverlays():
            delete_overlays \
              = self.delete_overlays_dialog.run() == gtk.RESPONSE_YES

            self.delete_overlays_dialog.hide()
            if not delete_overlays:
                # The user has just answered no, so we are not going
                # to proceed. Returning here is not necessary,
                # UpdateImages() fails if called with
                # delete_overlays=False and there exists some
                # overlays. By returning we avoid generating an
                # user-visible error which would just confuse the
                # user.
                return

        self.update_iface \
            .UpdateImages(False,
                          delete_overlays,
                          reply_handler=self.append_text_to_log,
                          error_handler=self.append_error_to_log)

        self.set_update_button_mode('updating')
        self.on_update_progress_indicator('starting')


    def view_log(self, widget):
        self.log_dialog.run()
        self.log_dialog.hide()


if __name__ == "__main__":
    user = pwd.getpwuid( os.getuid() ).pw_name
    puavolocaladmins = grp.getgrnam('puavolocaladmins').gr_mem
    if not user in puavolocaladmins:
        print('You do not have a permission to run this program',
              file=sys.stderr)
        sys.exit(1)

    applet = UpdateIndicatorApplet()
    gtk.main()
