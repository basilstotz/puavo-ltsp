#!/usr/bin/ruby1.9.1

require 'fileutils'
require 'json'
require 'puavo/rest-client'
require 'socket'
require 'syslog'

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end

def lookup_imageservers()
  imageservers = []

  puavo_domain = IO.read('/etc/puavo/domain').chomp

  begin
    imageservers \
      << Resolv::DNS.new.getresource("_imageserver._tcp.#{ puavo_domain }",
                                    Resolv::DNS::Resource::IN::SRV) \
           .target.to_s
  rescue Resolv::ResolvError
    log(Syslog::LOG_INFO, "could not find the image server from DNS\n")
  end

  device = JSON.parse( IO.read('/state/etc/puavo/device.json') )

  # XXX not used yet, it is unclear if this will ever be?
  if device['imageservers'].kind_of?(Array) then
    imageservers += device['imageservers']
  end

  topdomain = IO.read('/etc/puavo/topdomain').chomp
  imageservers << "images.#{ topdomain }"

  log(Syslog::LOG_INFO,
      "using image servers: %s\n",
      imageservers.join(' '))

  imageservers
end

def fetch_puavopkg_installer_bundle(bundlepath, targetpath)
  imageservers = lookup_imageservers()

  imageservers.each do |server|
    uri = "https://#{ server }/#{ bundlepath }"

    wget_ok = system('wget', '--ca-certificate=/etc/puavo/certs/rootca.pem',
                             "--output-document=#{ targetpath }",
                             '--timestamping',
                             uri,
                             { :out => '/dev/null',
                               :err => '/dev/null', })
    if !wget_ok then
      logerr(Syslog::LOG_WARNING,
             "failed to fetch %s from %s\n",
             bundlepath,
             server)
      next
    end

    log(Syslog::LOG_INFO, "fetched %s from %s\n", bundlepath, server)
    return
  end

  raise "Failed to fetch #{ bundlepath } from imageservers"
end

def puavo_rest_request_and_replace(restclient, uripath, filepath)
  data = restclient.get(uripath).to_s

  tmp_filepath = "#{ filepath }.tmp"
  File.open(tmp_filepath, 'w', 0600) { |f| f.write(data) }

  replace_if_changed(filepath, tmp_filepath)
end

def replace_if_changed(dest, src)
  if (FileUtils.cmp(dest, src) rescue false) then
    FileUtils.rm_f(src)
  else
    File.rename(src, dest)
  end
end

def run(*args)
  system(*args) or raise "Running system command #{ args } returned failure"
end

def grubedit(*args)
  run('grub-editenv', '/images/boot/grub/grubenv', *args)
end

def send_changed_primary_user_to_puavo(primary_user)
  log(Syslog::LOG_NOTICE,
      "Sending overridden primary user %s to Puavo\n",
      primary_user)

  cloud_restclient = PuavoRestClient.new(:auth    => :etc,
                                         :dns     => :no,
                                         :timeout => 30)

  senddata = { 'primary_user' => primary_user }

  uripath = "/v3/devices/#{ Socket.gethostname }"
  cloud_restclient.post(uripath, :json => senddata)
end

def update_device_json(restclient)
  log(Syslog::LOG_INFO, ">>> Updating device json\n")

  # We override the primary_user information in device.json from
  # /state/etc/puavo/primary_user_override if that exists.

  device_json_path = '/state/etc/puavo/device.json'

  uripath = "v3/devices/#{ Socket.gethostname }"
  device = restclient.get(uripath).parse()

  remove_primary_user_override = false

  primary_user_override \
    = IO.read('/state/etc/puavo/primary_user_override').chomp rescue nil

  if primary_user_override && !primary_user_override.empty? then
    if primary_user_override == device['primary_user'] then
      # remove override if we get the same information from Puavo
      remove_primary_user_override = true
    else
      begin
        send_changed_primary_user_to_puavo(primary_user_override)
      rescue PuavoRestClient::BadStatusCode => e
        logerr(Syslog::LOG_ERR,
               "Bad status code when sending primary user to Puavo: %s\n",
               e.response.to_s)
      rescue StandardError => e
        logerr(Syslog::LOG_ERR,
               "Problem sending primary user override to Puavo: %s\n",
               e.message)
      end
    end

    log(Syslog::LOG_ERR,
        "Applying primary user override: %s\n",
        primary_user_override)

    device['primary_user'] = primary_user_override
  end

  tmp_filepath = "#{ device_json_path }.tmp"
  File.open(tmp_filepath, 'w') { |f| f.write(device.to_json) }

  replace_if_changed(device_json_path, tmp_filepath)

  if remove_primary_user_override then
    log(Syslog::LOG_NOTICE,
        "Removing primary user override (it is the same in Puavo)\n")
    FileUtils.rm_f('/state/etc/puavo/primary_user_override')
  end
end

def update_external_files(restclient)
  log(Syslog::LOG_INFO, ">>> Updating external files\n")

  run('puavo-sync-external-files')
  run('puavo-handle-external-files-actions')
end

def update_grub_environment(restclient)
  log(Syslog::LOG_INFO, ">>> Updating grub environment\n")

  device = JSON.parse( IO.read('/state/etc/puavo/device.json') )

  kernel_version = device['kernel_version']
  if kernel_version && !kernel_version.empty? then
    grubedit('set', "puavo_kernel_version=#{ kernel_version }")
  else
    grubedit('unset', 'puavo_kernel_version')
  end

  if device['personally_administered'] == true then
    grubedit('set', 'puavo_show_imageoverlays=true')
  else
    grubedit('unset', 'puavo_show_imageoverlays')
  end

  kernel_arguments = device['kernel_arguments']
  if kernel_arguments && !kernel_arguments.empty? then
    grubedit('set', "puavo_kernel_arguments=#{ kernel_arguments }")
  else
    grubedit('unset', 'puavo_kernel_arguments')
  end
end

def update_wlan_configurations(restclient)
  log(Syslog::LOG_INFO, ">>> Updating wlan configurations\n")

  wlan_networks_uri = "v3/devices/#{ Socket.gethostname }/wlan_networks"
  puavo_rest_request_and_replace(restclient,
                                 wlan_networks_uri,
                                 '/state/etc/puavo/wlan.json')
end

def update_puavopkg_installers(restclient)
  if !File.readable?('/etc/puavo-pkg/installerbundlepath') then
    # If the image does not have installerbundlepath configured,
    # then we probably do not need to do anything.
    log(Syslog::LOG_DEBUG,
        "Not updating puavo-pkg installers, not configured.\n")
    return
  end

  log(Syslog::LOG_INFO, ">>> Updating puavo-pkg installers\n")

  puavopkg_dir = '/images/puavo-pkg'

  bundlepath = IO.read('/etc/puavo-pkg/installerbundlepath').chomp
  targetpath = "#{ puavopkg_dir }/puavo-pkg-installers-bundle.tar"

  fetch_puavopkg_installer_bundle(bundlepath, targetpath)

  latest_changetime = File.stat(targetpath).mtime

  current_installersdir \
    = "#{ puavopkg_dir }/installers.#{ latest_changetime.to_i }"

  if !File.directory?(current_installersdir) then
    log(Syslog::LOG_INFO, "Unpacking updated puavo-pkg installers\n")

    current_installers_tmpdir = "#{ current_installersdir }.tmp"
    FileUtils.mkdir_p(current_installers_tmpdir)
    run('tar', '-C', current_installers_tmpdir, '-x', '-f', targetpath)
    FileUtils.mv(current_installers_tmpdir, current_installersdir)
  end

  installerslinkpath = "#{ puavopkg_dir }/installers"
  current_linktarget = File.readlink(installerslinkpath) rescue nil
  new_linktarget = File.basename(current_installersdir)
  if current_linktarget != new_linktarget then
    log(Syslog::LOG_INFO, "Updating link to new puavo-pkg installers\n")
    File.symlink(new_linktarget, "#{ installerslinkpath }.tmp")
    File.rename("#{ installerslinkpath }.tmp", installerslinkpath)
  end

  # clean up old installer bundles
  Dir.glob("#{ puavopkg_dir }/installers.*") do |dir|
    next if dir == current_installersdir
    log(Syslog::LOG_INFO, "Removing old installers at %s\n", dir)
    FileUtils.remove_entry_secure(dir, true)
  end
end

Syslog.open(File.basename($0), Syslog::LOG_CONS)

restclient = PuavoRestClient.new(:auth => :etc, :timeout => 30)

#
# Update several (different) things.  Even if one thing cannot be updated,
# try to update others (order does not matter here, but do this sequentially
# anyway).  Return errors on exitcodes (from exitcode one should be able
# to figure out which parts failed).
#

# For exitcode calculation to work properly, there should not be more than
# sizeof(int) (32) functions here.  "device.json" should be updated first,
# because others may depend on it.
update_functions = [
  :update_device_json,
  :update_external_files,
  :update_wlan_configurations,
  :update_grub_environment,
  :update_puavopkg_installers,
]

exitcode = 0

i = 0
update_functions.each do |func|
  begin
    Object.send(func, restclient)
  rescue StandardError => e
    logerr(Syslog::LOG_ERR, "Problem in running %s: %s\n", func, e.message)
    exitcode |= (1 << i)
  end
  i += 1
end

Syslog.close()

exit(exitcode)
