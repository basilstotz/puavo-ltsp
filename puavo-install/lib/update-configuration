#!/usr/bin/ruby1.9.1

require 'fileutils'
require 'json'
require 'puavo/rest-client'
require 'socket'

def puavo_rest_request(restclient, urlpath)
  response = restclient.get(urlpath)
  raise "Rest request returned status code: #{ response.code }" \
    unless response.code == 200
  response
end

def puavo_rest_request_and_replace(restclient, urlpath, filepath)
  data = puavo_rest_request(restclient, urlpath).to_s

  tmp_filepath = "#{ filepath }.tmp"
  File.open(tmp_filepath, 'w', 0600) { |f| f.write(data) }

  replace_if_changed(filepath, tmp_filepath)
end

def replace_if_changed(dest, src)
  if (FileUtils.cmp(dest, src) rescue false) then
    FileUtils.rm_f(src)
  else
    File.rename(src, dest)
  end
end

def run(*args)
  system(*args) or raise "Running system command #{ args } returned failure"
end

def grubedit(*args)
  run('grub-editenv', '/images/boot/grub/grubenv', *args)
end

def update_device_json(restclient)
  puts('>>> Updating device json')

  # We override the primary_user information in device.json from
  # /state/etc/puavo/primary_user_override if that exists.

  # XXX The primary_user_override should be sent to Puavo so that it could be
  # XXX removed if device['primary_user'] == primary_user_override.
  # XXX (should that be done by puavo-client-daemon?).

  hostname = Socket.gethostname
  device_json_path = '/state/etc/puavo/device.json'

  device = puavo_rest_request(restclient, "v3/devices/#{ hostname }") \
             .parse()

  primary_user_override \
    = IO.read('/state/etc/puavo/primary_user_override').chomp rescue nil

  if primary_user_override && !primary_user_override.empty? then
    device['primary_user'] = primary_user_override
  end

  tmp_filepath = "#{ device_json_path }.tmp"
  File.open(tmp_filepath, 'w') { |f| f.write(device.to_json) }

  replace_if_changed(device_json_path, tmp_filepath)
end

def update_external_files(restclient)
  puts('>>> Updating external files')

  run('puavo-sync-external-files')
  run('puavo-handle-external-files-actions')
end

def update_grub_environment(restclient)
  puts('>>> Updating grub environment')

  device = JSON.parse( IO.read('/state/etc/puavo/device.json') )

  kernel_version = device['kernel_version']
  if kernel_version && !kernel_version.empty? then
    grubedit('set', "puavo_kernel_version=#{ kernel_version }")
  else
    grubedit('unset', 'puavo_kernel_version')
  end

  if device['personally_administered'] == true then
    grubedit('set', 'puavo_show_imageoverlays=true')
  else
    grubedit('unset', 'puavo_show_imageoverlays')
  end

  kernel_arguments = device['kernel_arguments']
  if kernel_arguments && !kernel_arguments.empty? then
    grubedit('set', "puavo_kernel_arguments=#{ kernel_arguments }")
  else
    grubedit('unset', 'puavo_kernel_arguments')
  end
end

def update_wlan_configurations(restclient)
  puts('>>> Updating wlan configurations')

  hostname = Socket.gethostname
  wlan_networks_uri = "v3/devices/#{ hostname }/wlan_networks"
  puavo_rest_request_and_replace(restclient,
                                 wlan_networks_uri,
                                 '/state/etc/puavo/wlan.json')
end

restclient = PuavoRestClient.new(:auth => :etc, :timeout => 60)

#
# Update several (different) things.  Even if one thing cannot be updated,
# try to update others (order does not matter here, but do this sequentially
# anyway).  Return errors on exitcodes (from exitcode one should be able
# to figure out which parts failed).
#

# For exitcode calculation to work properly, there should not be more than
# sizeof(int) (32) functions here.  "device.json" should be updated first,
# because others may depend on it.
update_functions = [
  :update_device_json,
  :update_external_files,
  :update_wlan_configurations,
  :update_grub_environment,
]

exitcode = 0

i = 0
update_functions.each do |func|
  begin
    Object.send(func, restclient)
  rescue StandardError => e
    warn "Problem in running #{ func }: #{ e.message }"
    exitcode |= (1 << i)
  end
  i += 1
end

exit(exitcode)
