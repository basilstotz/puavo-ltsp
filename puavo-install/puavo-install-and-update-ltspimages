#!/bin/sh

# obtain an exclusive lock on myself...
# there should be only one instance of this program running

exec 3<$0
flock -nx 3 || { echo did not get a lock, exiting; exit 1; }

#
# argument parsing
#

set -eu

log() {
    if $quiet && [ "$1" != "err" ]; then
            return 0
    fi
    echo "$2" | logger -p "$1" -s -t puavo-install-and-update-ltspimages
}

usage() {
  {
    echo "Usage:"
    echo "  $(basename $0) [--quiet] [--install-from-file path] next_ltsp_image_name"
    echo "  $(basename $0) [--quiet] [--install-from-nbd path]  next_ltsp_image_name"
    echo "  $(basename $0) [--quiet] [--rate-limit rate]        next_ltsp_image_name"
  } > /dev/stderr
  exit 1
}

if ! args=$(getopt -n "$0" -o +f:n:r:q \
		   -l 'install-from-file:,install-from-nbd:,rate-limit:,quiet' \
		   -- "$@"); then
  usage
fi

image_from_file=""
image_from_nbd=""
rate_limit_opts=""
quiet=false

eval "set -- $args"
while [ $# -ne 0 ]; do
  case "$1" in
    -f|--install-from-file)
      image_from_file="$2"; shift; shift
      ;;
    -n|--install-from-nbd)
      image_from_nbd="$2"; shift; shift
      ;;
    -r|--rate-limit)
      rate_limit_opts="--limit-rate $2"; shift; shift
      ;;
    -q|--quiet)
      quiet=true; shift;
      ;;
    --) shift; break;;      
  esac
done

{
  set +u
  next_image=$1
  set -u
}

if [ -z "$next_image" ]; then
  usage
fi

#
# subroutines
#

check_with_cksum() {
  filename=$1
  actual_file_path=$2
  checksums_file=$3

  if ! [ -r "$actual_file_path" ]; then
    log err "could not find a file $filename to check"
    return 1
  fi

  calculated_checksum_line="$(
    cksum "$actual_file_path" \
      | awk -v filename="$filename" '{ $3 = filename; print }')"

  if fgrep -qx "$calculated_checksum_line" "$checksums_file"; then
    log info "checksum for file $filename is okay"
    return 0
  else
    log err \
      "file $filename failed checksum check, removing $actual_file_path"
    rm -f "$actual_file_path"
    return 1
  fi
}

cleanup_previous_runs() {
  images_dir=$1
  rdiffs_dir=$2
  rdiff_filename=$3

  # cleanup old ltsp images (and their possible temporary *.tmp files).
  # The ltsp-backup.img is going to go too...
  old_images=$("/usr/lib/puavo-ltsp-install/ls-old-images" "${images_dir}")
  if [ -n "${old_images}" ]; then
      echo -n "${old_images}" | xargs -r -d'\n' -L1 rm -f
  fi

  # cleanup old rdiff files, except those that we want to use right now
  if [ -d "$rdiffs_dir" ]; then
    find "$rdiffs_dir" -maxdepth 1 -type f -a \
      '(' '(' -name '*.rdiff' -o -name '*.rdiff.tmp' ')' \
	  -a '!' '('    -name "${rdiff_filename}" \
		     -o -name "${rdiff_filename}.tmp" ')' ')' \
      -print0 \
    | xargs -0 rm -f
  fi
}

ensure_enough_available_diskspace() {
  images_dir=$1
  rdiffs_dir=$2

  # 133% of the space taken by the current image is probably enough
  # for updating to new image
  required_diskspace=$(stat -c '1.33 * %s' "${images_dir}/ltsp.img" \
			 | bc -l | xargs printf %.0f)

  for dir in "$images_dir" "$rdiffs_dir"; do 
    diskspace=$(stat -f -c '%S * %a' "$dir" | bc -l | xargs printf %.0f)
    if [ "$diskspace" -lt "$required_diskspace" ]; then
      msg="Only $diskspace bytes available on $dir,"
      msg="$msg need $required_diskspace bytes"
      log err "$msg"
      return 1
    fi
  done
}

fetch_with_curl() {
  extra_curl_opts=$1
  output_path=$2  
  url=$3

  # according to curl(1) --fail is not enough
  curl_status_code=$(
    curl --cacert /etc/puavo/certs/rootca.pem \
	 --continue-at - \
	 $extra_curl_opts \
	 --output "$output_path" \
	 -w "%{http_code}\n" \
	 "$url" \
      || true)

  case "$curl_status_code" in
    # 2*  == success
    # 416 == "Requested Range not satisfiable" (file should be finished)
    2*|416)
      log info "fetched $url with status code $curl_status_code"
      return 0
      ;;
    *)
      log err "fetching $url, curl returned status code $curl_status_code"
      return 1
      ;;
  esac
}

get_checksums_file() {
  extra_curl_opts=$1
  images_dir=$2
  url=$3

  checksum_file_path="${images_dir}/CKSUMS"

  fetch_with_curl "$extra_curl_opts -s" \
		  "${checksum_file_path}.tmp" \
		  "$url"
  mv "${checksum_file_path}.tmp" "${checksum_file_path}"

  echo "${checksum_file_path}"
}

get_next_image() {
  images_dir=$1
  next_image=$2
  rate_limit_opts=$3
  
  image_server=$(lookup_image_server_from_dns)

  rdiffs_dir=${images_dir}/rdiffs
  previous_image=$(lookup_ltspimage_name_by_alias "$images_dir" ltsp.img \
		     || true)

  if [ -z "$previous_image" ]; then
    log err 'Could not determine the current ltsp image name'
    return 1
  fi

  rdiff_filename=$(get_rdiff_filename $previous_image $next_image) || {
      log err "failed to determine the filename of rdiff between images \
'${previous_image}' and '${next_image}'"
      return 1
  }

  mkdir -p "$rdiffs_dir"

  cleanup_previous_runs "$images_dir" \
			"$rdiffs_dir" \
			"$rdiff_filename"

  ensure_enough_available_diskspace "$images_dir" "$rdiffs_dir"

  checksums_file=$(
    get_checksums_file "$rate_limit_opts" \
		       "$images_dir"      \
		       "https://${image_server}/rdiffs/CKSUMS")

  rdiff_url="https://${image_server}/rdiffs/${rdiff_filename}"

  get_rdiff "$rdiffs_dir"      \
	    "$rate_limit_opts" \
	    "$rdiff_filename"  \
	    "$rdiff_url"       \
	    "$checksums_file"

  patch_with_rdiff "$images_dir"     \
		   "$rdiffs_dir"     \
		   "$previous_image" \
		   "$next_image"     \
		   "$rdiff_filename" \
		   "$checksums_file"
}

get_rdiff() {
  rdiffs_dir=$1
  extra_curl_opts=$2
  rdiff_filename=$3
  rdiff_url=$4
  checksums_file=$5

  rdiff_path="${rdiffs_dir}/${rdiff_filename}"

  if [ -e "$rdiff_path" ]; then
    log info "the rdiff file $rdiff_filename is already in place"
    return 0
  fi

  log info "we are missing the full rdiff $rdiff_filename, going to get it"

  rdiff_tmp="${rdiff_path}.tmp"
  fetch_with_curl  "$extra_curl_opts" "$rdiff_tmp" "$rdiff_url"
  check_with_cksum "$rdiff_filename"  "$rdiff_tmp" "$checksums_file"

  sync
  mv "$rdiff_tmp" "$rdiff_path"

  log notice "new rdiff file $rdiff_filename has been put into its place"
}

get_rdiff_filename() {
  previous_image_name=$1
  next_image_name=$2

  echo "$previous_image_name $next_image_name" \
    | awk '
        NR == 1 {
	  orig   = $1
	  target = $2
	  regex  = "^(.*?)-([0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{6})-(.*?).img$"
     
	  if (match(orig, regex, orig_match) \
	    && match(target, regex, target_match)) {
	      printf("%s-%s--%s-%s.rdiff\n",
		     orig_match[1],
		     orig_match[2],
		     target_match[2],
		     orig_match[3])
	      exit(0)
	  }
	  else { exit(1) }
	}
      '
}

install_from_file_or_nbd() {
  images_dir=$1
  imagename=$2
  type_opt=$3
  type_arg=$4

  imagepath=$images_dir/$imagename

  test -e "$imagepath" && return 0

  cleanup_previous_runs "$images_dir" "${images_dir}/rdiffs" ''
  
  case "$type_opt" in
    -file)
      image_src_path=$type_arg
      total_size=$(du -k "$image_src_path" | awk '{ print $1 "k" }')
      ;;
    -nbd)
      image_src_path=$type_arg
      total_size=$(df "$image_src_path" \
		     | awk -v image_src_path="$image_src_path" '
			 $1 == image_src_path { print $2 "k" }
		       ')
      ;;
    *)
      log err "Internal error in install_from_file_or_nbd()"
      return 1
      ;;
  esac

  dd "if=$image_src_path" 2>/dev/null | pv -s "$total_size" \
    > "${imagepath}.tmp"
  sync
  mv "${imagepath}.tmp" "$imagepath"
  sync
}

install_image() {
  images_dir=$1
  imagename=$2
  type_opt=$3
  type_arg=$4

  current_ltspimage_name=$(lookup_ltspimage_name_by_alias "$images_dir" \
							  ltsp.img \
			     || true)
  if [ "$current_ltspimage_name" = "$imagename" ]; then
    echo "The wanted PuavoLTSP image $imagename"
    echo "is already in place."
    return 0
  fi

  if [ -n "$current_ltspimage_name" ]; then
    query_update_confirmation "$current_ltspimage_name" "$imagename"
  fi

  install_from_file_or_nbd "$images_dir" "$imagename" "$type_opt" "$type_arg"
  set_image_as_default_image "$images_dir" "$imagename"

  echo "The PuavoLTSP image $imagename"
  echo "is now installed and set as default."
}

lookup_image_server_from_dns() {
  puavo_domain=$(cat /etc/puavo/domain)
  image_server=$(
    dig SRV "_imageserver._tcp.${puavo_domain}" +search +short \
      | awk '{ sub(/\.$/, ""); printf "%s:%s", $4, $3 }')

  if [ -z "$image_server" ]; then
    # XXX take only the first image_server from "imageservers"...
    # XXX we are not yet capable of trying out several servers
    image_server=$(jq -r '.imageservers[]' /etc/puavo/device.json \
		     2>/dev/null | head -1) || true
    if [ -z "$image_server" ]; then
      image_server="images.$(cat /etc/puavo/topdomain)"
      log info "$(printf "%s %s\n" \
			 "could not find the image server from DNS, " \
			 "falling back to $image_server")"
    fi
  fi

  echo "$image_server"
}

lookup_ltspimage_name_by_alias() {
  images_dir=$1
  imagename=$2

  current_ltspimage_path="$images_dir/$imagename"
  current_ltspimage_inode="$(stat -c %i $current_ltspimage_path 2>/dev/null \
			       || true)"

  for file in $images_dir/*.img; do
    # check that *.img expands to something
    test -e "$file" || continue

    # ltsp.img is not what we are looking for
    test "$file" = "$current_ltspimage_path" && continue

    # we want its other name...
    if [ "$(stat -c %i "$file" || true)" = "$current_ltspimage_inode" ]; then
      echo "$(basename "$file")"
      return 0
    fi
  done

  return 1
}

patch_with_rdiff() {
  images_dir=$1
  rdiffs_dir=$2
  previous_image=$3
  next_image=$4
  rdiff_filename=$5
  checksums_file=$6

  # rdiff might fail due to a corrupt rdiff-file or for some other reason.
  # We let rdiff pass through in case of failure, and we check the correctness
  # of the output right after (removing the output if the checksum is bad).
  rdiff patch "${images_dir}/${previous_image}" \
	      "${rdiffs_dir}/${rdiff_filename}" \
	      "${images_dir}/${next_image}.tmp" \
    || true

  check_with_cksum "$next_image"                     \
		   "${images_dir}/${next_image}.tmp" \
		   "$checksums_file"

  sync
  mv "${images_dir}/${next_image}.tmp" "${images_dir}/${next_image}"

  log notice "new ltsp image $next_image has been put into its place"
}

query_update_confirmation() {
  current_ltspimage_name=$1
  new_ltspimage_name=$2

  cat <<EOF
The current PuavoLTSP image is $current_ltspimage_name,
but version $new_ltspimage_name is available.

Press ENTER to proceed to update it.
EOF
  read answer
}

# XXX duplicate code with puavo-install-ltspimages
set_image_as_default_image() {
  images_dir=$1
  imagename=$2
  imagepath=$images_dir/$imagename

  backup_ltspimage_path=$images_dir/ltsp-backup.img
  default_ltspimage_path=$images_dir/ltsp.img

  ln -f "$default_ltspimage_path" "$backup_ltspimage_path" 2>/dev/null || true
  ln -f "$imagepath" "${default_ltspimage_path}.tmp"
  sync
  mv "${default_ltspimage_path}.tmp" "$default_ltspimage_path"
  sync

  update_image_labels_for_grub "$images_dir"
  sync

  log notice "new ltsp image $next_image has been set as default"
}

update_image() {
  images_dir=$1
  next_image=$2
  rate_limit_opts=$3

  if [ ! -e "${images_dir}/${next_image}" ]; then
    log info "we are missing $next_image, going to get it"
    get_next_image "$images_dir" "$next_image" "$rate_limit_opts"
  fi

  # must call /usr/bin/test because /bin/sh is broken regarding this test
  if /usr/bin/test "${images_dir}/${next_image}" \
	       -ef "${images_dir}/ltsp.img"; then
    log info "the requested ltsp image is already in place"
  else
    puavo-install-grub --only-update-config
    set_image_as_default_image "$images_dir" "$next_image"
  fi
}

update_image_labels_for_grub() {
  images_dir=$1

  default_image=$(lookup_ltspimage_name_by_alias "$images_dir" ltsp.img \
		    || true)
  backup_image=$(lookup_ltspimage_name_by_alias "$images_dir" ltsp-backup.img \
		   || true)

  rm -f ${images_dir}/ltsp-*.backup ${images_dir}/ltsp-*.default

  test -n "$default_image" \
    && touch "${images_dir}/${default_image%.img}.default"
  test -n "$backup_image"  \
    && touch "${images_dir}/${backup_image%.img}.backup"

  return 0
}

#
# main
#

# be_very nice
ionice -c 3  -p $$
renice -n 20 -p $$ > /dev/null

images_dir=/images

# do nothing if /images/DISABLE_IMAGE_UPDATES exists
# (for development and emergencies)
test -e "${images_dir}/DISABLE_IMAGE_UPDATES" && exit 0

if [ -n "$image_from_file" ]; then
  install_image "$images_dir" "$next_image" -file "$image_from_file"
elif [ -n "$image_from_nbd" ]; then
  install_image "$images_dir" "$next_image" -nbd  "$image_from_nbd"
else
  update_image "$images_dir" "$next_image" "$rate_limit_opts"
fi

exit 0
