#!/usr/bin/env ruby1.9.3

require 'getoptlong'
require 'highline/import'
require 'json'
require 'net/https'
require 'securerandom'
require 'tempfile'

def ask_school(schools)
  school_names = []
  school_ids   = []

  schools.each() do |school|
    school_names << school['name']
    school_ids   << school['puavo_id']
  end

  say("\nWhich school the device shall be registered to?")
  choose() do |menu|
    school_ids.each_with_index() do |id, i|
      menu.choice(school_names[i]) { [school_names[i], id] }
    end
  end

end

def request_schools(https, username, password)
  schools = https.start() do |https|
    request = Net::HTTP::Get.new('/users/schools.json')
    request.basic_auth(username, password)

    response = https.request(request)
    response.value()

    JSON.parse(response.body())
  end
end

def request_register_device(https, username, password, school_id,
                            hostname, mac, hosttype)
  register_json = JSON.generate("puavoHostname"   => hostname,
                                "macAddress"      => mac,
                                "puavoDeviceType" => hosttype,
                                "classes"         => ["puavoNetbootDevice"])

  https.start() do |https|
    request = Net::HTTP::Post.new("/devices/#{school_id}/devices.json")
    request.basic_auth(username, password)
    request['Content-Type'] = 'application/json'
    request['Accept'] = 'application/json'
    request.body = register_json

    response = https.request(request)
    response.value()
  end
end

bootserver_hostname = File.read('/etc/puavo/hostname').strip()
testclient_hostname = "#{bootserver_hostname}-testclient2"
testclient_hosttype = "fatclient"
testclient_uuid = SecureRandom.uuid()

testclient_mac = 'aa:cc'
4.times { testclient_mac += ":#{SecureRandom.hex(1)}" }

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--hostname', GetoptLong::REQUIRED_ARGUMENT],
  ['--hosttype', GetoptLong::REQUIRED_ARGUMENT],
)

opts.each do |opt, arg|
  case opt
    when '--help'
      puts <<EOF
Usage: puavo-bootserver-create-testclient [OPTION]...

-h, --help                       display this help and exit
    --hostname HOSTNAME          set testclient's hostname to HOSTNAME, defaults to '#{testclient_hostname}'
    --hosttype HOSTTYPE          set testclient's hosttype to HOSTTYPE, defaults to '#{testclient_hosttype}'
EOF
    exit(0)
    when '--hostname'
      testclient_hostname = arg.to_s
    when '--hosttype'
      testclient_hosttype = arg.to_s
  end
end

if ARGV.length != 0
  STDERR.puts "invalid number of arguments (#{ARGV.length}), expected 0"
  exit 1
end

domain_xml = <<EOF
<domain type='kvm'>
  <name>#{testclient_hostname}</name>
  <uuid>#{testclient_uuid}</uuid>
  <memory unit='KiB'>524288</memory>
  <currentMemory unit='KiB'>524288</currentMemory>
  <vcpu placement='static'>1</vcpu>
  <os>
    <type arch='x86_64' machine='pc-1.0'>hvm</type>
    <boot dev='network'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <pae/>
  </features>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>/usr/bin/kvm</emulator>
    <controller type='usb' index='0'>
    </controller>
    <controller type='ide' index='0'>
    </controller>
    <interface type='bridge'>
      <mac address='#{testclient_mac}'/>
      <source bridge='ltsp0'/>
      <model type='e1000'/>
    </interface>
    <serial type='pty'>
      <target port='0'/>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <video>
      <model type='vga' vram='8192' heads='1'>
        <acceleration accel3d='no' accel2d='yes'/>
      </model>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
    </video>
    <memballoon model='virtio'>
    </memballoon>
  </devices>
</domain>
EOF

virsh_success = false
exitvalue = 1

at_exit do
  if exitvalue != 0 && virsh_success
    system('virsh', 'undefine', testclient_hostname)
  end
  exit(exitvalue)
end

tmpfile = Tempfile.new([testclient_hostname, '.xml'])
begin
  File.write(tmpfile.path, domain_xml)
  virsh_success = system('virsh', '--quiet', 'define', "#{tmpfile.path}")
ensure
  tmpfile.close()
  tmpfile.unlink()
end

if !virsh_success
  STDERR.puts("Failed to create virtual domain '#{testclient_hostname}'.")
  exit(1)
end

puts("Created virtual domain '#{testclient_hostname}'")

puavo_domain = File.read('/etc/puavo/domain').strip()

say("\nAdministrator credentials for organization #{puavo_domain}")
username = ask('Username: ')
password = ask('Password: ') { |q| q.echo = '*' }

https              = Net::HTTP.new(puavo_domain, 443)
https.use_ssl      = true
https.ca_path      = '/etc/ssl/certs'
https.verify_mode  = OpenSSL::SSL::VERIFY_PEER
https.verify_depth = 5

schools = request_schools(https, username, password)

school_name, school_id = ask_school(schools)

begin
  request_register_device(https, username, password, school_id,
                          testclient_hostname, testclient_mac, testclient_hosttype)
rescue Net::HTTPServerException => e
  STDERR.puts("Failed to register (error code #{e.response.code}) " \
              "'#{testclient_hostname}' to school '#{school_name}' " \
              "in organization '#{puavo_domain}'.")
  exit(1)
end

puts("Device '#{testclient_hostname}' registered to school '#{school_name}' " \
     "in organization '#{puavo_domain}'.")

exitvalue = 0
