#!/usr/bin/env ruby1.9.1

## Standard libraries.
require 'etc'
require 'getoptlong'
require 'json'
require 'socket'

## 3rd-party libraries.
require 'highline/import'
require 'puavobs'

def open_server(path)
  server_socket = Socket.new(Socket::AF_UNIX, Socket::SOCK_STREAM)
  old_umask = nil
  begin
    old_umask = File.umask(007)
    server_socket.bind(Socket.sockaddr_un(path))
  ensure
    if !old_umask.nil? then
      File.umask(old_umask)
    end
  end
  puavo_gid = Etc.getgrnam('puavo').gid
  File.chown(nil, puavo_gid, path)
  server_socket.listen(1)
  server_socket
end

has_colors = false
begin
  $has_colors = IO.popen(['tput', 'colors']) do |io|
    Integer(io.read()) >= 8
  end
rescue
  ## Just hide all errors, we do not care if color output support
  ## could not be tested properly. Colors are just eye-candies,
  ## nothing more.
end

def color(str, color_code)
  if $has_colors then
    "\e[#{color_code}m#{str}\e[0m"
  else
    str
  end
end

def color_red(str)
  color(str, 31)
end

def color_green(str)
  color(str, 32)
end

puts()
print <<'EOF'
             +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
             | ~= Puavo Bootserver Smoke Test =~ |
             +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
EOF
puts()

admin_username, admin_password = PuavoBS.ask_admin_credentials()
puts()

school_name, school_id = PuavoBS.ask_school(admin_username, admin_password)
puts()

say("Select the test device type:")
testclient_hosttype = choose() do |menu|
  ['fatclient', 'thinclient'].each() do |hosttype|
    menu.choice(hosttype) { hosttype }
  end
end
puts()

bootserver_hostname = File.read('/etc/puavo/hostname').strip()
testclient_hostname = "#{bootserver_hostname}-smoke-test"
testclient_tags     = []

### Create the test device and register the cleanup proc.
print('Create a test device ... ')
testclient_mac = nil
at_exit do
  ## Try to remove the virtual domain if it was created.
  if !testclient_mac.nil? then
    Process.wait(Process.spawn('virsh', 'undefine', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_mac = PuavoBS.virsh_define_testclient(testclient_hostname)
exit(1) if testclient_mac.nil?
puts(color_green('OK'))

### Create the test user.
print('Create a test user ... ')
testuser_username = nil
testuser_password = nil
at_exit do
  if !testuser_username.nil? then
    PuavoBS.remove_user(admin_username, admin_password,
                        school_id, testuser_username)
  end
end
testuser_username, testuser_password = PuavoBS.create_testuser(admin_username,
                                                               admin_password,
                                                               school_id)
testclient_tags << "autopilot:smoke:#{testuser_username}:#{testuser_password}"
puts(color_green('OK'))

### Register the test device and register the cleanup proc.
print('Register the test device ... ')
register_status = nil
at_exit do
  if !register_status.nil? then
    PuavoBS.unregister_device(admin_username, admin_password, testclient_hostname)
  end
end
register_status = PuavoBS.register_device(admin_username, admin_password,
                                          school_id,
                                          testclient_hostname, testclient_mac,
                                          testclient_hosttype, testclient_tags)
puts(color_green('OK'))

## Start monitoring log messages.
print('Start message monitor ... ')
server_socket = nil
at_exit do
  if !server_socket.nil? then
    server_socket.shutdown(Socket::SHUT_RDWR)
    server_socket.close()
    File.delete('/tmp/puavo-bootserver-smoke-test.socket')
  end
end
server_socket = open_server('/tmp/puavo-bootserver-smoke-test.socket')
puts(color_green('OK'))

### Boot up the test device and register the cleanup proc.
print('Boot up the test device ... ')
testclient_started = false
at_exit do
  ## Destroy the virtual domain if we started it.
  if testclient_started then
    Process.wait(Process.spawn('virsh', 'destroy', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_started = Process.wait2(Process.spawn('virsh', 'start',
                                                 testclient_hostname,
                                                 :out => '/dev/null'))[1].success?
exit(1) unless testclient_started
puts(color_green('OK'))

puts()
puts('Initialized the test with the following configuration:')
puts("  School      : #{school_name}")
puts("  Hosttype    : #{testclient_hosttype}")
puts("  Hostname    : #{testclient_hostname}")
puts("  MAC address : #{testclient_mac}")
puts("  Username    : #{testuser_username}")
puts('')

expected_msgs = case testclient_hosttype
                when 'fatclient'
                  ['enter-display-manager-screen',
                   'try-display-manager-login',
                   'begin-user-session']
                when 'thinclient'
                  ['begin-user-session']
                else
                  []
                end

max_msg_name_length = expected_msgs.map() { |s| s.length }.max()
num_msgs = expected_msgs.length
received_msgs = []

expected_msgs.each_with_index() do |expected_msg, i|
  padding = '.' * (max_msg_name_length - expected_msg.length)
  print("Step #{i+1}/#{num_msgs}: Receive '#{expected_msg}' ...#{padding} ")

  ## If haven't received any messaged, wait for them and then fill
  ## received_msgs.
  if received_msgs.empty? then
    result = IO.select([server_socket], [], [], 120)
    if result.nil? then
      puts(color_red('FAIL') + ': timeout')
      exit(1)
    end

    ## Ensure client socket gets closed properly afterwards.
    client_socket = nil
    begin
      client_socket, client_addrinfo = server_socket.accept()
      received_msgs += client_socket.readlines().map() do |line|
        JSON.parse(line)['msg']
      end
    ensure
      if !client_socket.nil? then
        client_socket.shutdown(Socket::SHUT_RDWR)
        client_socket.close()
      end
    end

  end

  ## Test messages in the order they were received.
  msg = received_msgs.shift()
  if msg != expected_msg then
    puts(color_red('FAIL') + ": received '#{msg}'")
    exit(1)
  end
  puts(color_green('OK'))

end
