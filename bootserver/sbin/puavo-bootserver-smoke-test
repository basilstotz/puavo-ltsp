#!/usr/bin/env ruby1.9.1

## Standard libraries.
require 'etc'
require 'getoptlong'
require 'json'
require 'socket'

## 3rd-party libraries.
require 'highline/import'
require 'puavobs'

def open_server(path)
  server_socket = Socket.new(Socket::AF_UNIX, Socket::SOCK_STREAM)
  old_umask = nil
  begin
    old_umask = File.umask(007)
    server_socket.bind(Socket.sockaddr_un(path))
  ensure
    if !old_umask.nil? then
      File.umask(old_umask)
    end
  end
  puavo_gid = Etc.getgrnam('puavo').gid
  File.chown(nil, puavo_gid, path)
  server_socket.listen(1)
  server_socket
end

admin_username, admin_password = PuavoBS.ask_admin_credentials()
puts()

school_name, school_id = PuavoBS.ask_school(admin_username, admin_password)
puts()

puts('Running a smoke test:')

bootserver_hostname = File.read('/etc/puavo/hostname').strip()
testclient_hostname = "#{bootserver_hostname}-smoke-test"
testclient_hosttype = 'fatclient'
testclient_tags     = []

### Create the test device and register the cleanup proc.
testclient_mac = nil
at_exit do
  ## Try to remove the virtual domain if it was created.
  if !testclient_mac.nil?
    Process.wait(Process.spawn('virsh', 'undefine', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_mac = PuavoBS.virsh_define_testclient(testclient_hostname)
exit(1) if testclient_mac.nil?


### Create the test user.
testuser_username = nil
testuser_password = nil
at_exit do
  if !testuser_username.nil? then
    PuavoBS.remove_user(admin_username, admin_password,
                        school_id, testuser_username)
  end
end
testuser_username, testuser_password = PuavoBS.create_testuser(admin_username,
                                                               admin_password,
                                                               school_id)
testclient_tags << "autopilot:smoke:#{testuser_username}:#{testuser_password}"


### Register the test device and register the cleanup proc.
register_status = nil
at_exit do
  if !register_status.nil?
    PuavoBS.unregister_device(admin_username, admin_password, testclient_hostname)
  end
end
register_status = PuavoBS.register_device(admin_username, admin_password,
                                          school_id,
                                          testclient_hostname, testclient_mac,
                                          testclient_hosttype, testclient_tags)

## Start monitoring log messages.
server_socket = nil
at_exit do
  if !server_socket.nil? then
    server_socket.shutdown(Socket::SHUT_RDWR)
    server_socket.close()
    File.delete('/tmp/puavo-bootserver-smoke-test.socket')
  end
end
server_socket = open_server('/tmp/puavo-bootserver-smoke-test.socket')

### Boot up the test device and register the cleanup proc.
testclient_started = false
at_exit do
  ## Destroy the virtual domain if we started it.
  if testclient_started
    Process.wait(Process.spawn('virsh', 'destroy', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_started = Process.wait2(Process.spawn('virsh', 'start',
                                                 testclient_hostname,
                                                 :out => '/dev/null'))[1].success?
exit(1) unless testclient_started

puts("  School       : #{school_name}")
puts("  Hosttype     : #{testclient_hosttype}")
puts("  Hostname     : #{testclient_hostname}")
puts("  MAC address  : #{testclient_mac}")
puts("  Username     : #{testuser_username}")
puts()

expected_msgs = ['enter-display-manager-screen',
                 'try-display-manager-login',
                 'begin-user-session']
max_msg_name_length = expected_msgs.map() { |s| s.length }.max()
num_msgs = expected_msgs.length
received_msgs = []

expected_msgs.each_with_index() do |expected_msg, i|
  padding = ' ' * (max_msg_name_length - expected_msg.length)
  print("Stage #{i+1}/#{num_msgs}: Wait for '#{expected_msg}'#{padding} ... ")

  ## If haven't received any messaged, wait for them and then fill
  ## received_msgs.
  if received_msgs.empty? then
    result = IO.select([server_socket], [], [], 120)
    if result.nil? then
      puts('FAIL: timeout')
      exit(1)
    end

    ## Ensure client socket gets closed properly afterwards.
    client_socket = nil
    begin
      client_socket, client_addrinfo = server_socket.accept()
      received_msgs += client_socket.readlines().map() do |line|
        JSON.parse(line)['msg']
      end
    ensure
      if !client_socket.nil? then
        client_socket.shutdown(Socket::SHUT_RDWR)
        client_socket.close()
      end
    end

  end

  ## Test messages in the order they were received.
  msg = received_msgs.shift()
  if msg != expected_msg then
    puts("FAIL: got '#{msg}'")
    exit(1)
  end
  puts('OK')

end
