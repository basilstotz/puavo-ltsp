#!/usr/bin/env ruby1.9.1

## Standard libraries.
require 'etc'
require 'getoptlong'
require 'json'
require 'socket'

## 3rd-party libraries.
require 'highline/import'
require 'puavobs'

def open_server(path)
  server_socket = Socket.new(Socket::AF_UNIX, Socket::SOCK_STREAM)
  old_umask = nil
  begin
    old_umask = File.umask(007)
    server_socket.bind(Socket.sockaddr_un(path))
  ensure
    if !old_umask.nil? then
      File.umask(old_umask)
    end
  end
  puavo_gid = Etc.getgrnam('puavo').gid
  File.chown(nil, puavo_gid, path)
  server_socket.listen(1)
  server_socket
end

admin_username, admin_password = PuavoBS.ask_admin_credentials()
school_name, school_id = PuavoBS.ask_school(admin_username, admin_password)
bootserver_hostname = File.read('/etc/puavo/hostname').strip()
testclient_hostname = "#{bootserver_hostname}-smoke-test"
testclient_hosttype = 'fatclient'
testclient_tags     = []

### Create the test device and register the cleanup proc.
testclient_mac = nil
at_exit do
  ## Try to remove the virtual domain if it was created.
  if !testclient_mac.nil?
    Process.wait(Process.spawn('virsh', 'undefine', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_mac = PuavoBS.virsh_define_testclient(testclient_hostname)
exit(1) if testclient_mac.nil?


### Create the test user.
testuser_username = nil
testuser_password = nil
at_exit do
  if !testuser_username.nil? then
    PuavoBS.remove_user(admin_username, admin_password,
                        school_id, testuser_username)
  end
end
testuser_username, testuser_password = PuavoBS.create_testuser(admin_username,
                                                               admin_password,
                                                               school_id)
testclient_tags << "autopilot:smoke:#{testuser_username}:#{testuser_password}"


### Register the test device and register the cleanup proc.
register_status = nil
at_exit do
  if !register_status.nil?
    PuavoBS.unregister_device(admin_username, admin_password, testclient_hostname)
  end
end
register_status = PuavoBS.register_device(admin_username, admin_password,
                                          school_id,
                                          testclient_hostname, testclient_mac,
                                          testclient_hosttype, testclient_tags)


puts('Initialized an autopilot:')
puts("  School       : #{school_name}")
puts("  Hosttype     : #{testclient_hosttype}")
puts("  Hostname     : #{testclient_hostname}")
puts("  MAC address  : #{testclient_mac}")
puts("  Username     : #{testuser_username}")

puts('Starting the autopilot monitor.')
server_socket = nil
at_exit do
  if !server_socket.nil? then
    server_socket.shutdown(Socket::SHUT_RDWR)
    server_socket.close()
    File.delete('/tmp/puavo-bootserver-smoke-test.socket')
  end
end
server_socket = open_server('/tmp/puavo-bootserver-smoke-test.socket')

puts('Launching the autopilot.')
### Boot up the test device and register the cleanup proc.
testclient_started = false
at_exit do
  ## Destroy the virtual domain if we started it.
  if testclient_started
    Process.wait(Process.spawn('virsh', 'destroy', testclient_hostname,
                               :out => '/dev/null'))
    exit(1) unless $?.success?
  end
end
testclient_started = Process.wait2(Process.spawn('virsh', 'start',
                                                 testclient_hostname,
                                                 :out => '/dev/null'))[1].success?
exit(1) unless testclient_started

puts('---')

expected_stages = ['enter-display-manager-screen', 'try-display-manager-login', 'begin-user-session']

expected_stages.each() do |expected_stage|
  print("Stage '#{expected_stage}': ")
  result = IO.select([server_socket], [], [], 120)
  if result.nil? then
    STDERR.puts('FAIL: timeout')
    exit(1)
  end
  client_socket = nil
  begin
    client_socket, client_addrinfo = server_socket.accept()
    client_socket.readlines().each() do |line|
      log_entry = JSON.parse(line)
      stage = log_entry['msg']
      if stage != expected_stage then
        STDERR.puts("FAIL: unexpected stage '#{stage}', " \
                    "expected '#{expected_stage}'")
        exit(1)
      else
        puts('DONE')
      end
    end
  ensure
    if !client_socket.nil? then
      client_socket.shutdown(Socket::SHUT_RDWR)
      client_socket.close()
    end
  end
end
