#!/usr/bin/env ruby1.9.1

## Standard libraries.
require 'etc'
require 'getoptlong'
require 'json'
require 'socket'

## 3rd-party libraries.
require 'highline/import'
require 'puavobs'

def color(str, color_code)
  unless defined?($has_colors) then
    $has_colors = false
    begin
      $has_colors = IO.popen(['tput', 'colors']) do |io|
        Integer(io.read()) >= 8
      end
    rescue
      ## Just hide all errors, we do not care if color output support
      ## could not be tested properly. Colors are just eye-candies,
      ## nothing more.
    end
  end

  return "\e[#{color_code}m#{str}\e[0m" if $has_colors
  str
end

def color_red(str)
  color(str, 31)
end

def color_green(str)
  color(str, 32)
end

class TestRunError < StandardError
end

class TestRun

  def initialize(admin_username, admin_password,
                 school_id, testclient_hosttype)
    @admin_username             = admin_username
    @admin_password             = admin_password
    @school_id                  = school_id
    @testclient_hosttype        = testclient_hosttype
    bootserver_hostname         = File.read('/etc/puavo/hostname').strip()
    @testclient_hostname        = "#{bootserver_hostname}-smoke-test"
    @testclient_tags            = []
    @testclient_mac             = nil
    @testclient_register_status = nil
    @testclient_started         = false
    @testuser_username          = nil
    @testuser_password          = nil
    @server_socket              = nil
    @server_socket_path         = '/tmp/puavo-bootserver-smoke-test.socket'
  end

  def prepare()
    puts('---')
    return false if !prepare_define_testclient()
    return false if !prepare_add_testuser()
    return false if !prepare_register_testclient()
    return false if !prepare_open_socket()
    return false if !prepare_start_testclient()
    true
  end

  def execute()
    puts('---')
    expected_msgs = case @testclient_hosttype
                    when 'fatclient'
                      ['enter-display-manager-screen',
                       'try-display-manager-login',
                       'begin-user-session']
                    when 'thinclient'
                      ['begin-user-session']
                    else
                      []
                    end

    n = expected_msgs.length
    received_msgs = []

    expected_msgs.each_with_index() do |expected_msg, i|
      print("Execute: receive #{i + 1}/#{n}: #{expected_msg} ... ")
      begin
        ## If haven't received any messaged, wait for them and then fill
        ## received_msgs.
        if received_msgs.empty? then
          result = IO.select([@server_socket], [], [], 120)
          raise TestRunError.new('timeout') if result.nil?

          ## Ensure client socket gets closed properly afterwards.
          client_socket = nil
          begin
            client_socket, client_addrinfo = @server_socket.accept()
            received_msgs += client_socket.readlines().map() do |line|
              JSON.parse(line)['msg']
            end
          ensure
            if !client_socket.nil? then
              client_socket.shutdown(Socket::SHUT_RDWR)
              client_socket.close()
            end
          end
        end

        ## Test messages in the order they were received.
        msg = received_msgs.shift()
        raise TestRunError.new("got #{msg}") if msg != expected_msg
      rescue TestRunError => e
        puts(color_red('FAIL') + ": #{e.message}")
        return false
      rescue StandardError, Interrupt => e
        puts(color_red('FAIL') + ': unexpected error')
        raise
      else
        puts(color_green('OK'))
      end
    end

    true
  end

  def cleanup()
    puts('---')
    cleanup_methods = [:cleanup_destroy_testclient,
                       :cleanup_close_socket,
                       :cleanup_unregister_testclient,
                       :cleanup_remove_testuser,
                       :cleanup_undefine_testclient,
                      ]
    first_exception = nil
    cleanup_methods.each do |m|
      begin
        send(m)
      rescue StandardError, Interrupt => e
        if first_exception.nil? then
          first_exception = e
        end
      end
    end
    raise first_exception unless first_exception.nil?
  end

  private

  def prepare_define_testclient()
    print('Prepare: define a virtual test device ... ')
    begin
      @testclient_mac = PuavoBS.virsh_define_testclient(@testclient_hostname)
    rescue StandardError, Interrupt
      puts(color_red('FAIL'))
      raise
    else
      if @testclient_mac.nil? then
        puts(color_red('FAIL'))
        return false
      end
      puts(color_green('OK'))
    end
    true
  end

  def prepare_add_testuser()
    print('Prepare: add a test user to Puavo ... ')
    begin
      (@testuser_username,
       @testuser_password) = PuavoBS.create_testuser(@admin_username,
                                                     @admin_password,
                                                     @school_id)
    rescue StandardError, Interrupt
      puts(color_red('FAIL'))
      raise
    else
      puts(color_green('OK'))
      tag = "autopilot:smoke:#{@testuser_username}:#{@testuser_password}"
      @testclient_tags << tag
    end
    true
  end

  def prepare_register_testclient()
    print('Prepare: register the virtual test device to Puavo ... ')
    begin
      @testclient_register_status = PuavoBS.register_device(@admin_username,
                                                            @admin_password,
                                                            @school_id,
                                                            @testclient_hostname,
                                                            @testclient_mac,
                                                            @testclient_hosttype,
                                                            @testclient_tags)
    rescue StandarError, Interrupt
      puts(color_red('FAIL'))
      raise
    else
      puts(color_green('OK'))
    end
    true
  end

  def prepare_open_socket()
    print('Prepare: open a message socket ... ')
    begin
      server_socket = Socket.new(Socket::AF_UNIX, Socket::SOCK_STREAM)
      old_umask = nil
      begin
        old_umask = File.umask(007)
        server_socket.bind(Socket.sockaddr_un(@server_socket_path))
      ensure
        if !old_umask.nil? then
          File.umask(old_umask)
        end
      end
      puavo_gid = Etc.getgrnam('puavo').gid
      File.chown(nil, puavo_gid, @server_socket_path)
      server_socket.listen(1)
      @server_socket = server_socket
    rescue StandardError, Interrupt
      puts(color_red('FAIL'))
      raise
    else
      if @server_socket.nil? then
        puts(color_red('FAIL'))
        return false
      end
      puts(color_green('OK'))
    end
    true
  end

  def prepare_start_testclient()
    print('Prepare: start the virtual test device ... ')
    begin
      Process.wait(Process.spawn('virsh', 'start',
                                 @testclient_hostname,
                                 :out => '/dev/null'))
    rescue StandardError, Interrupt
      puts(color_red('FAIL'))
      raise
    else
      @testclient_started = $?.success?
      if !@testclient_started then
        puts(color_red('FAIL'))
        return false
      end
      puts(color_green('OK'))
    end
    true
  end

  def cleanup_undefine_testclient()
    if !@testclient_mac.nil? then
      print('Cleanup: undefine the virtual test device ... ')
      begin
        Process.wait(Process.spawn('virsh', 'undefine', @testclient_hostname,
                                   :out => '/dev/null'))
      rescue StandardError, Interrupt
        puts(color_red('FAIL'))
        raise
      else
        if !$?.success? then
          puts(color_red('FAIL'))
          raise 'failed to undefine the virtual domain'
        end
        puts(color_green('OK'))
      end
    end
  end

  def cleanup_remove_testuser()
    if !@testuser_username.nil? then
      print('Cleanup: remove the test user from Puavo ... ')
      begin
        PuavoBS.remove_user(@admin_username, @admin_password,
                            @school_id, @testuser_username)
      rescue StandardError, Interrupt
        puts(color_red('FAIL'))
        raise
      else
        puts(color_green('OK'))
      end
    end
  end

  def cleanup_unregister_testclient()
    if !@testclient_register_status.nil? then
      print('Cleanup: unregister the virtual test device from Puavo ... ')
      begin
        PuavoBS.unregister_device(@admin_username, @admin_password,
                                  @testclient_hostname)
      rescue StandardError, Interrupt
        puts(color_red('FAIL'))
        raise
      else
        puts(color_green('OK'))
      end
    end
  end

  def cleanup_close_socket()
    if !@server_socket.nil? then
      print('Cleanup: close the message socket ... ')
      begin
        @server_socket.shutdown(Socket::SHUT_RDWR)
        @server_socket.close()
        File.delete(@server_socket_path)
      rescue StandardError, Interrupt
        puts(color_red('FAIL'))
        raise
      else
        puts(color_green('OK'))
      end
    end
  end

  def cleanup_destroy_testclient()
    if @testclient_started then
      print('Cleanup: destroy the virtual test device ... ')
      begin
        Process.wait(Process.spawn('virsh', 'destroy', @testclient_hostname,
                                   :out => '/dev/null'))
      rescue StandardError, Interrupt
        puts(color_red('FAIL'))
        raise
      else
        if !$?.success? then
          puts(color_red('FAIL'))
          raise 'failed to destroy the virtual domain'
        end
        puts(color_green('OK'))
      end
    end
  end

end

lockfile = File.open('/run/puavo-bootserver-smoke-test.lock',
                     File::RDWR|File::CREAT, 0644)
if !lockfile.flock(File::LOCK_NB|File::LOCK_EX) then
  puts('ERROR: failed to obtain an exclusive run lock, ' \
       'perhaps another instance is already running?')
  exit(1)
end

print <<'EOF'

             +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
             | ~= Puavo Bootserver Smoke Test =~ |
             +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

EOF

admin_username, admin_password = PuavoBS.ask_admin_credentials()

school_name, school_id = PuavoBS.ask_school(admin_username, admin_password)

say("Select the test device type:")
testclient_hosttype = choose() do |menu|
  ['fatclient', 'thinclient'].each() do |hosttype|
    menu.choice(hosttype) { hosttype }
  end
end

testrun = TestRun.new(admin_username, admin_password,
                      school_id, testclient_hosttype)

begin
  exit(1) if !testrun.prepare()
  exit(1) if !testrun.execute()
ensure
  testrun.cleanup()
end
