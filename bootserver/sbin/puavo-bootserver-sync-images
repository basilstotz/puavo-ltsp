#!/usr/bin/ruby1.9.3

# ##############################################################################
#
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# ##############################################################################
#
# Managed images
#
# Images downloaded by this script, data stored under /var/lib/puavo/images.json
# Unmanaged images - other images
#
# By default the script handles only the managed images and unmanaged images
# are left untouched. The script can be asked to delete unmanaged images with 
# command line option --delete-unmanaged. When asked, the script will delete 
# all unknown files under /opt/ltsp/images and /opt/ltsp/images/rdiffs. Images 
# do not need to have .img ending.
#
# Operation
#
# Steps done by the script:
#
# 1. Check image series source URLs from device.json
# 2. Load image series description JSON files from specified URLs
# 3. Determine wanted full images oldest first and start syncing them one by one oldest first
# 4. Check if there is an old image available that has a diff to wanted target image
# 5. Download diffs needed by locally installed client devices
# 6. Delete old unused managed images + rdiffs
# 7. Delete unmanaged images if asked
#
# The managed images and rdiffs are stored under /var/lib/puavo/images.json. The 
# contents of the file are the same as the last loaded image series json file. 

require "digest"
require 'digest/sha2'
require 'fileutils'
require 'json'
require 'net/http'
require 'puavo'
require 'puavo/etc'
require 'puavo/rest-client'
require 'rest-client'
require 'syslog'

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end

def debug(msg);   log(Syslog::LOG_DEBUG,   "%s\n", msg); end
def info(msg);    log(Syslog::LOG_INFO,    "%s\n", msg); end
def warning(msg); log(Syslog::LOG_WARNING, "%s\n", msg); end

class Result
  attr_reader :succeeded, :message

  def initialize(succeeded, message)
    @succeeded = succeeded
    @message   = message
  end
end

class Series
  attr_reader :name

  def initialize(name)
    @name = name

    @by_id = Hash.new
    @by_version = Hash.new
  end

  def add_image(image)
    @by_id[image.id] = @by_version[image.version] = image
  end

  def get_by_id(id)
    return @by_id[id]
  end

  def get_by_version(version)
    return @by_version[version]
  end

  def mark_image_in_use(image_id)
    image = @by_id[image_id]
    if image
      image.mark_in_use
    end
  end

  def mark_diff_in_use(old_image_id, new_image_id)
    old_image = @by_id[old_image_id]
    new_image = @by_id[new_image_id]

    if old_image && new_image
      new_image.mark_diff_in_use(old_image)
    end
  end

  def add_diff(from_version, to_version, filename, size, sha256, urls)
    baseimage = get_by_version(from_version)
    targetimage = get_by_version(to_version)

    if baseimage && targetimage
      diff = Diff.new(baseimage, targetimage, filename, size, sha256, urls)
      targetimage.add_diff(diff)
    end
  end

  def images
    return @by_version.values
  end

  # Returns specified number of newest images in an array. The images are
  # sorted oldest first so that when fetching the images, newer images can 
  # be created using diffs from older images.
  def newest_images(limit)
    newest_by_version(@by_version, limit)
  end
end

class SyncFile
  def initialize(filename, sha256, size, urls)
    @filename = filename
    @sha256   = sha256
    @size     = size
    @urls     = urls

    @in_use        = false
    @mtime         = nil
    @verified      = false
    @verify_result = false
  end

  def delete
    all_possible_paths.each do |path|
      next unless File.exists?(path)
      info "Deleting '#{ path }'"
      begin
        File.delete(path)
      rescue StandardError => e
        warning "Could not delete '#{ path }': #{ e.message }"
      end
    end
  end

  def download
    # go through all @urls in order and try to download from each in turn
    # (we could also do some load balancing by first choosing one randomly?)
    @urls.each do |url|
      download_from_url(url) and return true
    end

    return false
  end

  # Download file from specified url and check that the sha256 checksum of 
  # the downloaded file matches the given size and sha256.
  # If the file was downloaded successfully and the size and the checksum
  # matches, true is returned, otherwise false is returned.
  def download_from_url(url)
    uri = URI.parse(url)

    http = Net::HTTP.new(uri.host, uri.port)
    http.ca_file = "/etc/puavo/certs/rootca.pem"
  #  http.ca_file = "/etc/ssl/certs/SecureTrust_CA.pem" # XXX ?
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    http.use_ssl = true

    http.request_get(uri.path) do |response|
      case response
      when Net::HTTPNotFound
        warning "404 - Not Found (#{url})"
        return false

      when Net::HTTPOK
        hash = Digest::SHA2.new
        received_size = 0

        File.open(download_path, "w") do |temp_file|
          temp_file.binmode

          progress = 0
          total = response.header["Content-Length"].to_i

          response.read_body do |chunk|
            hash      << chunk
            temp_file << chunk

            received_size += chunk.size
            new_progress = (received_size * 100) / total
            if progress != new_progress
              progress = new_progress
              info "Downloading %s (%3d%%)" % [download_path, progress]
            end
          end
        end

        return false unless received_size == @size

        if hash.to_s == @sha256
          # verification happens while downloading, so no need to verify
          # it later.
          FileUtils.mv(download_path, final_path)
          return true
        end
      else
        warning "puavo-rest-client error, received response #{response.code}"
        return false
      end
    end

    return false
  end

  def do_path_cleanup(path)
    # The point of this is to check that filename does not get out of
    # basedir by having ".." or some such, it must be under basedir
    # (where the meaning of basedir is different for images and diffs).
    cleaned_up_path = File.expand_path(path)
    return cleaned_up_path if path.start_with?(basedir)

    raise "Invalid filename #{ path }"
  end

  def all_possible_paths
    [ download_path, unverified_path, final_path ]
  end

  def download_path
    return do_path_cleanup("#{ unverified_path }.partial")
  end

  def final_path
    return do_path_cleanup("#{ basedir }/#{ @filename }")
  end

  def unverified_path
    return do_path_cleanup("#{ final_path }.unverified")
  end

  def file_inplace
    return File.exists?(final_path)
  end

  def mark_in_use
    @in_use = true
  end

  # Checks if the file in the filesystem has the same sha256 as the metadata.
  # To speed up things, the filesize needs to match before sha256 is 
  # calculated. The results are cached and rechecked only if file mtime 
  # changes.
  def verify
    # XXX if --force-verify command-line option is given, this step should
    # XXX be skipped:
    file_inplace and return true

    begin
      current_mtime = File.mtime(unverified_path)
      current_size  = File.size(unverified_path)
    rescue Errno::ENOENT
      return @verified = @verify_result = false
    rescue StandardError => e
      warning "Problem in inspecting #{ unverified_path }: #{ e.message }"
      return @verified = @verify_result = false
    end

    if @verified && @mtime && @mtime == current_mtime
      return @verify_result
    end

    @verify_result = false

    if current_size == @size
      @mtime = current_mtime
      digest = Digest::SHA2.file(unverified_path).hexdigest
      @verify_result = (digest == @sha256)
      if @verify_result
        FileUtils.mv(unverified_path, final_path)
      end
    end

    @verified = true

    return @verify_result
  end
end

class Image < SyncFile
  attr_reader :version, :filename, :size, :sha256, :urls, :in_use, :id

  def initialize(version, filename, size, sha256, id, urls)
    super(filename, sha256, size, urls)

    @version = version
    @diffs_from_by_version = Hash.new

    if id
      @id = id
    elsif /\A(.*)\.img\z/.match(filename)
      @id = $1
    else
      raise "Could not determine id for '#{ filename }'"
    end
  end

  def basedir; '/opt/ltsp/images'; end

  def mark_diff_in_use(from_image)
    diff = @diffs_from_by_version[from_image.version]
    if diff
      diff.mark_in_use
    end
  end

  def add_diff(diff)
    return unless diff.targetimage.version == @version

    if diff.baseimage.version != @version
      @diffs_from_by_version[diff.baseimage.version] = diff
    end
  end

  def diffs
    @diffs_from_by_version.values
  end

  def download_newest_diffs(limit=0)
    newest_by_version(@diffs_from_by_version, limit).each do |diff|
      diff.mark_in_use
      diff.verify or diff.download
    end
  end

  # Figure out how to 
  def materialize
    verify and return Result.new(true, "Image exists already")

    patch_from_old and return Result.new(true,
                                         "Patched from older image")

    download and return Result.new(true, "Downloaded full image")

    return Result.new(false, "Failed to patch or download image")
  end

  # Create the current image from an old image by using a patch. First 
  # all the possible diffs are sorted by size and the list is scanned twice:
  # first to check if there is an existing baseimage that has a patch 
  # available and if none is found, then the smallest sized diff for an 
  # existing baseimage is downloaded.
  def patch_from_old
    mindiffs = diffs.sort_by { |diff| diff.size }

    apply_diffs = lambda do |download_wanted|
                    mindiffs.each do |diff|
                      diff.apply(:download_wanted => download_wanted) \
                        and verify                                    \
                        and return true
                    end
                    return false
                  end

    apply_diffs.call(false) and return true
    debug "No existing diff, downloading the smallest"
    apply_diffs.call(true)  and return true

    return false
  end

  def delete
    diffs.each { |diff| diff.delete }
    super
  end
end

class Diff < SyncFile
  attr_reader :baseimage, :targetimage, :filename, :size, :sha256, :urls, :in_use

  def initialize(baseimage, targetimage, filename, size, sha256, urls)
    super(filename, sha256, size, urls)

    @baseimage   = baseimage
    @targetimage = targetimage

    @in_use = false
  end

  def basedir; '/opt/ltsp/images/rdiffs'; end

  def do_patching
    return true if system("rdiff",
                          "patch",
                          @baseimage.final_path,
                          final_path,
                          @targetimage.unverified_path)

    warning "rdiff failed with exit code: #{ $?.exitstatus } when using" \
              + " '#{ final_path }'"
    return false      
  end

  def apply(opts)
    download_wanted = opts[:download_wanted]

    @baseimage.verify \
      and ((download_wanted or verify) or download) \
      and do_patching                               \
      and return true

    return false
  end
end

def newest_by_version(collection_by_version, limit)
  versions = collection_by_version.keys.sort.reverse.slice(0,limit).reverse
  return versions.map { |version| collection_by_version[version] }
end

# XXX not used yet, how should this be used?
def load_managed_images
  images = Hash.new

  begin
    if File.exists?("/var/lib/puavo/images.json")
      json = JSON.parse(File.read("/var/lib/puavo/images.json"))

    end
  rescue StandardError => e
    puts "Reading /var/lib/puavo/images.json failed: #{e}"
  end

  images
end

# XXX not used yet, how should this be used?
def write_managed_images(images)
  File.open("/var/lib/puavo/images.json", "w") do |f|
    f.write(images.to_json)
  end
end

def parse_series_data(series_data)
  result = Hash.new

  series_data.each_pair do |key, data|
    series = Series.new(key)

    data["images"].each do |image|
      image = Image.new(image["version"],
                        image["filename"],
                        image["size"],
                        image["sha256"],
                        image["id"],
                        [ image["url"] ])
      series.add_image(image)
    end

    data["images"].each do |image|
      if image["diffs"]
        image["diffs"].each do |data|
          series.add_diff(data["version"],
                          image["version"],
                          data["filename"],
                          data["size"],
                          data["sha256"],
                          [ data["url"] ])
        end
      end
    end

    result[key] = series
  end

  result
end


#
def fetch_source_urls
  etc = PuavoEtc.new
  client = PuavoRestClient.new :auth => :etc

  url = "/v3/boot_servers/#{ etc.hostname }"

  debug "Loading bootserver data from puavo-rest url: '#{ url }'"
  res = client.get(url)
  data = res.parse()

  source_urls = data["image_series_sources"]

  raise 'Could not read sources urls from Puavo' \
    unless source_urls.kind_of?(Array)

  return source_urls
end

# Load series json definition files 
def load_series_data(sources)
  all_series = Hash.new

  info "Using image series sources:"
  sources.each { |url| info url }

  sources.each do |url|
    uri = URI.parse(url)

    http = Net::HTTP.new(uri.host, uri.port)
    http.ca_file = "/etc/puavo/certs/rootca.pem"
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    http.use_ssl = true

    http.request_get(uri.path) do |response|
      series = parse_series_data(JSON.parse(response.body))

      all_series.merge!(series)
    end
  end

  all_series
end

# Query puavo-rest for all devices and check used images. Images and 
# diffs are marked
def query_devices(series)
  client = PuavoRestClient.new :auth => :etc

  res = client.get("/v3/devices")
  devices = res.parse()

  devices.each do |device|
    preferred_image = device["preferred_image"]
    boot_image = device["preferred_boot_image"]
    current_image = device["current_image"]

    bootmode = device["boot_mode"]

    if bootmode && bootmode == "netboot"
      # Netboot devices do not need diffs
      series.mark_image_in_use(preferred_image)
      series.mark_image_in_use(boot_image)
    else
      # Other devices need diffs from current image to preferred 

      if preferred_image && current_image && preferred_image == current_image
        series.mark_diff_in_use(current_image, preferred_image)
      end

      series.mark_image_in_use(preferred_image)
    end
  end
end

script_name = File.basename(__FILE__)

Syslog.open(script_name, Syslog::LOG_CONS)

options = Hash.new

parser = OptionParser.new do |opts|
  opts.banner = <<BANNER_EOF
  Image sync tool for bootservers to download client images from image server.
  This tool touches only files that have .img or rdiff ending.

  Image series is a collection of images that are based on same underlying
  system.  They are versioned and updates from older to newer versions are
  supported.

  Images are downloaded from an image server. The series is defined by a JSON
  file that contains information about images and diffs.  The image source
  URL is defined in bootserver settings in Puavo and the script queries the
  information from puavo-rest by default.  Series information is parsed from
  the JSON files and by default the following images and diffs are downloaded:

  * Newest image from each series
  * Diffs from 2nd and 3rd newest image in the series
  * All images used by netboot devices
  * All preferred images used by non-netboot devices
  * All diffs needed by non-netboot devices to update from the current image
    to preferred images

  All files have checksums that are checked before they are actually used.
  
  An example that defines two images and a diff between them:

{
  "demo-trusty": {
    "images": [
      {
        "size": 10146996224,
        "sha256": "24e2f84a89a0b0126e0cfd457fe016016181e82f9e49d437fd465de69525b271",
        "url": "https://imageserver.puavo.org/demo-trusty-2015-03-25-104000-i386.img",
        "filename": "demo-trusty-2015-03-25-104000-i386.img",
        "id": "demo-trusty-2015-03-25-104000-i386",
        "version": 20150325104000
      },
      {
        "diffs": [
          {
            "url": "https://imageserver.puavo.org/rdiffs/demo-trusty-2015-03-25-104000--2015-04-10-103142-i386.rdiff",
            "sha256": "f00a308de2ad01e0a27507412faca5faed288318a225f40d4cd261b647f689fb",
            "size": 735394218,
            "version": 20150325104000,
            "filename": "demo-trusty-2015-03-25-104000--2015-04-10-103142-i386.rdiff"
          },
        ],
        "size": 10213441536,
        "sha256": "432cb4055664d0c1dc3d9e6a58833ef7939dd5af24d9af2e47f6607ea88f5c60",
        "url": "https://imageserver.puavo.org/demo-trusty-2015-04-10-103142-i386.img",
        "filename": "demo-trusty-2015-04-10-103142-i386.img",
        "id": "demo-trusty-2015-04-10-103142-i386",
        "version": 20150410103142
      },
    ]
  }
}


  Usage: #{script_name} [options]

  Options:
BANNER_EOF

  opts.on("--keep-unused", "Do no delete images that are not currently used by any client.") do
    options[:keep_unused] = true
  end

  opts.on("--url URL", "Source URL to load JSON series information") do |url|
    options[:url] = url
  end

  opts.on("--file PATH", "JSON series information file to read") do |file|
    options[:file] = file
  end

  options[:image_limit] = 1
  opts.on("--image-limit NUMBER", "Number of newest images to sync from all specified series (Default: 1)") do |limit|
    options[:image_limit] = limit
  end

  options[:diff_limit] = 2
  opts.on("--diff-limit NUMBER", "Number of newest diffs to sync for synced images even if there are no clients using them. (Default: 2)") do |limit|
    options[:diff_limit] = limit
  end

  # XXX not used yet
  options[:download_path] = "/opt/ltsp/images"
  opts.on("--download_path PATH") do |path|
    options[:download_path] = path
  end

  opts.on("--series NAME", "Download only specified series instead of all series specified by the sources.") do |series|
    options[:series] = series
  end

  opts.on("--image NAME", "Sync only the specified image") do |image|
    options[:image] = image
  end

  opts.on_tail("-h", "--help", "Show this message") do
    STDERR.puts opts
    exit
  end
end

parser.parse!

image_limit=options[:image_limit]
diff_limit=options[:diff_limit]
sync_client_diffs=true

if options[:image]
  sync_client_diffs=false
end

delete_unused = true

if options[:keep_unused]
  delete_unused = false
end

begin
  # Load series information from sources specified in bootserver's
  # device information.
  if options[:file]
    all_series = parse_series_data( JSON.parse( IO.read(options[:file]) ) )
  else
    if options[:url]
      source_urls = [ options[:url] ]
    else
      source_urls = fetch_source_urls()
    end
    all_series = load_series_data(source_urls)
  end

  if options[:series]
    series_name = options[:series]
    debug "Using only series #{series_name}"

    all_series.keep_if {|key, value| key.eql?(series_name)}
  end

  if all_series.empty?
    warning "No series information, exiting"
    exit 1
  end

  all_series.values.each do |series|
    debug "Syncing series #{series.name}"

    if options[:image]
      image_list = [ series.get_by_id(options[:image]) ]
      diff_limit = 0
    else
      # Check which images and diffs are needed for non-netboot devices
      query_devices(series)

      # We want to always download X number of newest images with Y number 
      # of diffs from newest images.
      image_list = series.newest_images(image_limit)
    end

    image_list.each do |image|
      debug "#{image.id} - starting sync"

      image.mark_in_use

      result = image.materialize
      if result.succeeded
        info "#{image.id} - image sync ok: #{result.message}"
      else
        warning "#{image.id} - image sync failed: #{result.message}"
      end

      image.download_newest_diffs(diff_limit)
    end

    if sync_client_diffs
      debug "Downloading client diffs"

      series.images.each do |image|
        image.diffs.each do |diff|
          next unless diff.in_use

          if diff.verify
            debug "#{diff.filename} - exists already"
          elsif diff.download
            info "#{diff.filename} - diff sync ok"
          else
            warning "#{diff.filename} - diff sync failed"
          end
        end
      end
    end

    # Delete all images and rdiffs that are not either newest
    # or used by some client
    if delete_unused
      debug "Checking for old images and diffs to delete"

      series.images.each do |image|
        if !image.in_use
          image.delete	# does delete all diffs to image as well
          next
        end

        unused_diffs = image.diffs.select { |diff| !diff.in_use }
        unused_diffs.each do |diff|
          diff.delete
        end
      end
    end
  end
rescue StandardError => e
  warning "Error: #{ e.message }"
  raise e
end

Syslog.close()

exit 0
