#!/usr/bin/ruby1.9.3

# ##############################################################################
#
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# ##############################################################################
#
# Managed images
#
# Images downloaded by this script, data stored under /var/lib/puavo/images.json
# Unmanaged images - other images
#
# By default the script handles only the managed images and unmanaged images
# are lef untouched. The script can be asked to delete unmanaged images with 
# command line option --delete-unmanaged. When asked, the script will delete 
# all unknown files under /opt/ltsp/images and /opt/ltsp/images/rdiffs. Images 
# do not need to have .img ending.
#
# Operation
#
# Steps done by the script:
#
# 1. Check image series source URLs from device.json
# 2. Load image series description JSON files from specified URLs
# 3. Determine wanted full images oldest first and start syncing them one by one oldest first
# 4. Check if there is an old image available that has a diff to wanted target image
# 5. Download diffs needed by locally installed client devices
# 6. Delete old unused managed images + rdiffs
# 7. Delete unmanaged images if asked
#
# The managed images and rdiffs are stored under /var/lib/puavo/images.json. The 
# contents of the file are the same as the last loaded image series json file. 

require 'puavo'
require 'rest-client'
require 'json'
require 'net/http'
require "digest"
require 'digest/sha2'
require 'syslog'
require 'puavo/etc'
require 'puavo/rest-client'

def syslog(channel, priority, *args)
  Syslog.log(priority, *args)
  channel.printf(*args)
end

def log(*args)   ; syslog(STDOUT, *args); end
def logerr(*args); syslog(STDERR, *args); end

def debug(msg);   log(Syslog::LOG_DEBUG,   "%s\n", msg); end
def info(msg);    log(Syslog::LOG_INFO,    "%s\n", msg); end
def warning(msg); log(Syslog::LOG_WARNING, "%s\n", msg); end

class Result
  attr_reader :succeeded, :message

  def initialize(succeeded, message)
    @succeeded = succeeded
    @message   = message
  end
end

class Series
  attr_reader :name, :arch

  def initialize(name, arch)
    @name = name
    @arch = arch

    @by_id = Hash.new
    @by_version = Hash.new
  end

  def add_image(image)
    @by_id[image.id] = @by_version[image.version] = image
  end

  def get_by_id(id)
    return @by_id[id]
  end

  def get_by_version(version)
    return @by_version[version]
  end

  def mark_image_in_use(image_id)
    image = @by_id[image_id]

    if image
      image.mark_in_use
    else
      warning "Series is missing image #{image_id}"
    end
  end

  def mark_diff_in_use(old_image_id, new_image_id)
    old_image = @by_id[old_image_id]
    new_image = @by_id[new_image_id]

    if old_image && new_image
      new_image.mark_diff_in_use(old_image)
    else
      warning "Series is missing diff from #{old_image_id} to #{new_image_id}"
    end
  end

  def add_diff(from_version, to_version, filename, size, sha256, urls)
    baseimage = get_by_version(from_version)
    targetimage = get_by_version(to_version)

    if baseimage && targetimage
      diff = Diff.new(baseimage, targetimage, filename, size, sha256, urls)
      targetimage.add_diff(diff)
    elsif !baseimage
      warning "base image #{from_version} is missing"
    elsif !targetimage
      warning "target image #{to_version} is missing"
    else
      warning "base image #{from_version} and target image #{to_version} are missing"
    end
  end

  def images
    return @by_version.values
  end

  # Returns specified number of newest images in an array. The images are
  # sorted oldest first so that when fetching the images, newer images can 
  # be created using diffs from older images.
  def newest(limit)
    versions = @by_version.keys.sort.reverse.slice(0,limit).reverse
    return versions.map { |version| @by_version[version] }
  end
end

class SyncFile
  def initialize(filename, sha256, size, urls)
    @filename = filename
    @sha256   = sha256
    @size     = size
    @urls     = urls

    @mtime         = nil
    @verified      = false
    @verify_result = false
  end

  def delete
    begin
      File.delete(full_path)
    rescue StandardError => e
      warning "Could not delete '#{ full_path }': #{ e.message }"
    end
  end

  def full_path
    # The point of this is to check that filename does not get out of
    # basedir by having ".." or some such.
    path = File.expand_path("#{ basedir }/#{ @filename }")
    return path if path.start_with?(basedir)

    raise "Invalid filename #{ @filename }"
  end

  # Checks if the file in the filesystem has the same sha256 as the metadata.
  # To speed up things, the filesize needs to match before sha256 is 
  # calculated. The results are cached and rechecked only if file mtime 
  # changes.
  def verify
    begin
      current_mtime = File.mtime(full_path)
      current_size  = File.size(full_path)
    rescue StandardError => e
      warning "Problem in inspecting #{ full_path }: #{ e.message }"
      # we can not verify something which evades even basic inspection
      @verified = false
      @verify_result = false
      return false
    end

    if @verified && @mtime && current_mtime == @mtime
      return @verify_result
    end

    @verify_result = false

    if current_size == @size
      @mtime = current_mtime
      @verify_result = Digest::SHA2.file(full_path).hexdigest.eql?(@sha256)
    end

    @verified = true

    return @verify_result
  end
end

class Image < SyncFile
  attr_reader :version, :filename, :size, :sha256, :urls, :diffs_from_older, :in_use, :id

  def initialize(version, filename, size, sha256, id, urls)
    super(filename, sha256, size, urls)

    @version = version
    @diffs_from_older = Hash.new
    @diffs_to_newer = Hash.new	# XXX not used for anything yet,
				# XXX remove if no use appears
    @in_use = false

    if id
      @id = id
    elsif /\A(.*)\.img\z/.match(filename)
      @id = $1
    else
      raise "Could not determine id for '#{ filename }'"
    end
  end

  def basedir; '/opt/ltsp/images'; end

  def mark_in_use
    @in_use = true
  end

  def mark_diff_in_use(from_image)
    diff = @diffs_from_older[from_image.version]

    if diff
      diff.mark_in_use
    end
  end

  def add_diff(diff)
    # Not a diff for this?
    return unless diff.targetimage.version == @version \
                    || diff.baseimage.version == @version

    if diff.baseimage.version < @version
      @diffs_from_older[diff.baseimage.version] = diff
    end

    # XXX remove unless something will use this
    if diff.baseimage.version == @version && diff.targetimage.version > @version
      @diffs_to_newer[diff.targetimage.version] = diff
    end
  end

  def download
    download_file(@urls[0], full_path, size, sha256)
  end

  def newest_diffs(limit=0)
    versions = @diffs_from_older.keys.sort.reverse.slice(0,limit).reverse
    return versions.map {|version| @diffs_from_older[version] }
  end

  def download_newest_diffs(limit=0)
    @diffs_from_older.keys.sort.reverse.slice(0,limit).reverse.each do |key|
      diff = @diffs_from_older[key]
      diff.verify or diff.download
    end
  end

  # Figure out how to 
  def materialize
    verify and return Result.new(true, "Image exists already")

    patch_from_old and return Result.new(true,
                                         "Patched from older image")

    download and return Result.new(true, "Downloaded full image")

    return Result.new(false, "Failed to patch or download image")
  end

  # Create the current image from an old image by using a patch. First 
  # all the possible diffs are sorted by size and the list is scanned twice:
  # first to check if there is an existing baseimage that has a patch 
  # available and if none is found, then the smallest sized diff for an 
  # existing baseimage is downloaded.
  def patch_from_old
    mindiffs = @diffs_from_older.sort_by { |version, diff| diff.size }.values

    apply_diffs = lambda do |download_wanted|
                    mindiffs.each do |diff|
                      diff.apply(:download_wanted => download_wanted) \
                        and return true
                    end
                    return false
                  end

    apply_diffs.call(false) and return true
    debug "No existing diff, downloading the smallest"
    apply_diffs.call(true)  and return true

    return false
  end

  def delete
    @diffs_from_older.each do |diff|
      diff.delete
    end

    super
  end
end

class Diff < SyncFile
  attr_reader :baseimage, :targetimage, :filename, :size, :sha256, :urls, :in_use

  def initialize(baseimage, targetimage, filename, size, sha256, urls)
    super(filename, sha256, size, urls)

    @baseimage   = baseimage
    @targetimage = targetimage

    @in_use = false
  end

  def basedir; '/opt/ltsp/images/rdiffs'; end

  def do_patching
    return true if system("rdiff",
                          "patch",
                          @baseimage.full_path,
                          full_path,
                          @targetimage.full_path)

    warning "rdiff failed with exit code: #{ $?.exitstatus } when using" \
              + " '#{ full_path }'"
    return false      
  end

  def apply(opts)
    download_wanted = opts[:download_wanted]

    @baseimage.verify \
      and ((not download_wanted) or download) \
      and verify                              \
      and do_patching                         \
      and return true

    return false
  end

  def download
    download_file(@urls[0], full_path, size, sha256)
  end

  def mark_in_use
    @in_use = true
  end
end

# XXX not used yet, how should this be used?
def load_managed_images
  images = Hash.new

  begin
    if File.exists?("/var/lib/puavo/images.json")
      json = JSON.parse(File.read("/var/lib/puavo/images.json"))

    end
  rescue StandardError => e
    puts "Reading /var/lib/puavo/images.json failed: #{e}"
  end

  images
end

# XXX not used yet, how should this be used?
def write_managed_images(images)
  File.open("/var/lib/puavo/images.json", "w") do |f|
    f.write(images.to_json)
  end
end

# Download file from specified url and check that the sha256 checksum of 
# the downloaded file matches the given size and sha256.
#
# If the file was downloaded successfully and the size and the checksum
# matches, true is returned, otherwise false is returned.
def download_file(url, dest_file, expected_size, sha256)
  uri = URI.parse(url)

  http = Net::HTTP.new(uri.host, uri.port)
  http.ca_file = "/etc/puavo/certs/rootca.pem"
#  http.ca_file = "/etc/ssl/certs/SecureTrust_CA.pem"	# XXX ?
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER
  http.use_ssl = true

  http.request_get(uri.path) do |response|
    puts response.inspect
    hash = Digest::SHA2.new

    case response
    when Net::HTTPNotFound
      warning "404 - Not Found (#{url})"
      return false

    when Net::HTTPClientError
      warning "Error: Client Error: #{response.inspect}"
      return false

    when Net::HTTPOK
      temp_file = File.new(dest_file, "w")
      temp_file.binmode

      received_size = 0
      progress = 0
      total = response.header["Content-Length"].to_i

      response.read_body do |chunk|
        hash << chunk

        temp_file << chunk
        received_size += chunk.size
        new_progress = (received_size * 100) / total
        unless new_progress == progress
          puts "\rDownloading %s (%3d%%) " % [dest_file, new_progress]
        end

        progress = new_progress
      end

      temp_file.close()

      return false if expected_size != received_size

      if hash.to_s.eql?(sha256)
        return true
      end
    end
  end

  return false
end

def parse_series_data(series_data)
  result = Hash.new

  series_data.each_pair do |key, data|
    series = Series.new(key, data["architecture"])

    data["images"].each do |image|
      image = Image.new(image["version"],
                        image["filename"],
                        image["size"],
                        image["sha256"],
                        image["id"],
                        [ image["url"] ])
      series.add_image(image)
    end

    data["images"].each do |image|
      if image["diffs"]
        image["diffs"].each do |data|
          series.add_diff(data["version"],
                          image["version"],
                          data["filename"],
                          data["size"],
                          data["sha256"],
                          [ data["url"] ])
        end
      end
    end

    result[key] = series
  end

  result
end


#
def fetch_source_urls
  etc = PuavoEtc.new
  client = PuavoRestClient.new :auth => :etc

  url = "/v3/boot_servers/#{ etc.hostname }"

  debug "Loading bootserver data from puavo-rest url: '#{ url }'"
  res = client.get(url)
  data = res.parse()

  source_urls = data["image_series_sources"]

  raise 'Could not read sources urls from Puavo' \
    unless source_urls.kind_of?(Array)

  return source_urls
end

# Load series json definition files 
def load_series_data(sources)
  all_series = Hash.new

  info "Using image series sources:"
  sources.each { |url| info url }

  sources.each do |url|
    uri = URI.parse(url)

    http = Net::HTTP.new(uri.host, uri.port)
    http.ca_file = "/etc/puavo/certs/rootca.pem"
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    http.use_ssl = true

    http.request_get(uri.path) do |response|
      series = parse_series_data(JSON.parse(response.body))

      all_series.merge!(series)
    end
  end

  all_series
end

# Query puavo-rest for all devices and check used images. Images and 
# diffs are marked
def query_devices(series)
  client = PuavoRestClient.new :auth => :etc

  res = client.get("/v3/devices")
  devices = res.parse()

  devices.each do |device|
    preferred_image = device["preferred_image"]
    boot_image = device["preferred_boot_image"]
    current_image = device["current_image"]

    bootmode = device["boot_mode"]

    if bootmode && bootmode.eql?("netboot")
      # Netboot devices do not need diffs
      series.mark_image_in_use(preferred_image)
      series.mark_image_in_use(boot_image)
    else
      # Other devices need diffs from current image to preferred 

      if preferred_image && current_image && !preferred_image.eql?(current_image)
        series.mark_diff_in_use(current_image, preferred_image)
      end

      series.mark_image_in_use(preferred_image)
    end
  end
end

script_name = File.basename(__FILE__)

Syslog.open(script_name, Syslog::LOG_CONS)

options = Hash.new

parser = OptionParser.new do |opts|
  opts.banner = <<BANNER_EOF
  Image sync tool for bootservers to download client images from image server.
  This tool touches only files that have .img or rdiff ending.

  Image series is a collection of images that are based on same underlying
  system.  They are versioned and updates from older to newer versions are
  supported.

  Images are downloaded from an image server. The series is defined by a JSON
  file that contains information about images and diffs.  The image source
  URL is defined in bootserver settings in Puavo and the script queries the
  information from puavo-rest by default.  Series information is parsed from
  the JSON files and by default the following images and diffs are downloaded:

  * Newest image from each series
  * Diffs from 2nd and 3rd newest image in the series
  * All images used by netboot devices
  * All preferred images used by non-netboot devices
  * All diffs needed by non-netboot devices to update from the current image
    to preferred images

  All files have checksums that are checked before they are actually used.
  
  An example that defines two images and a diff between them:

{
  "demo-trusty": {
    "architecture": "i386"
    "images": [
      {
        "size": 10146996224,
        "sha256": "24e2f84a89a0b0126e0cfd457fe016016181e82f9e49d437fd465de69525b271",
        "url": "https://imageserver.puavo.org/demo-trusty-2015-03-25-104000-i386.img",
        "filename": "demo-trusty-2015-03-25-104000-i386.img",
        "id": "demo-trusty-2015-03-25-104000-i386",
        "version": 20150325104000
      },
      {
        "diffs": [
          {
            "url": "https://imageserver.puavo.org/rdiffs/demo-trusty-2015-03-25-104000--2015-04-10-103142-i386.rdiff",
            "sha256": "f00a308de2ad01e0a27507412faca5faed288318a225f40d4cd261b647f689fb",
            "size": 735394218,
            "version": 20150325104000,
            "filename": "demo-trusty-2015-03-25-104000--2015-04-10-103142-i386.rdiff"
          },
        ],
        "size": 10213441536,
        "sha256": "432cb4055664d0c1dc3d9e6a58833ef7939dd5af24d9af2e47f6607ea88f5c60",
        "url": "https://imageserver.puavo.org/demo-trusty-2015-04-10-103142-i386.img",
        "filename": "demo-trusty-2015-04-10-103142-i386.img",
        "id": "demo-trusty-2015-04-10-103142-i386",
        "version": 20150410103142
      },
    ]
  }
}


  Usage: #{script_name} [options]

  Options:
BANNER_EOF

  opts.on("--keep-unused", "Do no delete images that are not currently used by any client.") do
    options[:keep_unused] = true
  end

  opts.on("--url URL", "Source URL to load JSON series information") do |url|
    options[:url] = url
  end

  opts.on("--file PATH", "JSON series information file to read") do |file|
    options[:file] = file
  end

  options[:image_limit] = 1
  opts.on("--image-limit NUMBER", "Number of newest images to sync from all specified series (Default: 1)") do |limit|
    options[:image_limit] = limit
  end

  options[:diff_limit] = 2
  opts.on("--diff-limit NUMBER", "Number of newest diffs to sync for synced images even if there are no clients using them. (Default: 2)") do |limit|
    options[:diff_limit] = limit
  end

  # XXX not used yet
  options[:download_path] = "/opt/ltsp/images"
  opts.on("--download_path PATH") do |path|
    options[:download_path] = path
  end

  opts.on("--series NAME", "Download only specified series instead of all series specified by the sources.") do |series|
    options[:series] = series
  end

  opts.on("--image NAME", "Sync only the specified image") do |image|
    options[:image] = image
  end

  opts.on_tail("-h", "--help", "Show this message") do
    STDERR.puts opts
    exit
  end
end

parser.parse!

image_limit=options[:image_limit]
diff_limit=options[:diff_limit]
sync_client_diffs=true

if options[:image]
  sync_client_diffs=false
end

delete_unused = true

if options[:keep_unused]
  delete_unused = false
end

begin
  # Load series information from sources specified in bootserver's
  # device information.
  if options[:file]
    all_series = parse_series_data( JSON.parse( IO.read(options[:file]) ) )
  else
    if options[:url]
      source_urls = [ options[:url] ]
    else
      source_urls = fetch_source_urls()
    end
    all_series = load_series_data(source_urls)
  end

  if options[:series]
    series_name = options[:series]
    debug "Using only series #{series_name}"

    all_series.keep_if {|key, value| key.eql?(series_name)}
  end

  if all_series.empty?
    warning "No series information, exiting"
    exit 1
  end

  all_series.values.each do |series|
    debug "Syncing series #{series.name}"

    if options[:image]
      image_list = [ series.get_by_id(options[:image]) ]
      diff_limit = 0
    else
      # Check which images and diffs are needed for non-netboot devices
      query_devices(series)

      # We want to always download X number of newest images with Y number 
      # of diffs from newest images.
      image_list = series.newest(image_limit)
    end

    image_list.each do |image|
      debug "#{image.id} - starting sync"

      image.mark_in_use

      result = image.materialize
      if result.succeeded
        info "#{image.id} - image sync ok: #{result.message}"
      else
        warning "#{image.id} - image sync failed: #{result.message}"
      end

      image.newest_diffs(diff_limit).each do |diff|
        diff.mark_in_use
      end

      image.download_newest_diffs(diff_limit)
    end

    if sync_client_diffs
      debug "Downloading client diffs"

      series.images.each do |image|
        image.diffs_from_older.values.each do |diff|
          if diff.in_use
            if diff.verify
              debug "#{diff.filename} - exists already"
            elsif diff.download
              info "#{diff.filename} - diff sync ok"
            else
              warning "#{diff.filename} - diff sync failed"
            end
          end
        end
      end
    end

    # Delete all images and rdiffs that are not either newest
    # or used by some client
    if delete_unused
      debug "Checking for old images and diffs to delete"

      series.images.each do |image|
        if !image.in_use
          debug "Delete image and all diff for #{image.id}"

          image.delete
        else
          image.diffs_from_older.values.each do |diff|
            if !diff.in_use
              puts diff.inspect

              info "Delete diff: #{diff.filename}"

              diff.delete
            end
          end
        end
      end
    end
  end
rescue StandardError => e
  warning "Error: #{ e.message }"
  raise e
end

Syslog.close()

exit 0
