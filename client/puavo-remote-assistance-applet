#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import appindicator
import errno
import fcntl
import getpass
import gtk
import os
import subprocess
import sys

class RemoteAccessHandler:
    def enable_remote_access(self, widget=None):
        self.enable_gnome_remote_access()
        self.enable_ssh_remote_access()


    def enable_gnome_remote_access(self):
        dconf_values = {
          '/org/gnome/desktop/remote-access/enabled':            "true",
          '/org/gnome/desktop/remote-access/icon-visibility':    "'client'",
          '/org/gnome/desktop/remote-access/network-interface':  "'tap0'",
          '/org/gnome/desktop/remote-access/notify-on-connect':  "true",
          '/org/gnome/desktop/remote-access/prompt-enabled':     "true",
          '/org/gnome/desktop/remote-access/require-encryption': "true",
          '/org/gnome/desktop/remote-access/view-only':          "false",
        }

        # starts vino-server as a side-effect
        self.set_dconf_values(dconf_values)


    def enable_ssh_remote_access(self):
        self.call_puavo_admin_remote_connections([ '--accept-incoming' ])


    def check_gnome_remote_access_is_allowed(self):
        dconf_key = '/org/gnome/desktop/remote-access/enabled'
        out = subprocess.check_output([ 'dconf', 'read', dconf_key ])

        return (out.rstrip(os.linesep) == 'true')


    def check_ssh_remote_access_is_allowed(self):
        args = [ '--is-incoming-accepted' ]
        status = self.call_puavo_admin_remote_connections(args)

        return (status.rstrip(os.linesep) == 'yes')


    def disable_remote_access(self, widget=None):
        self.disable_gnome_remote_access()
        self.disable_ssh_remote_access()


    def disable_gnome_remote_access(self):
        dconf_values = {
          '/org/gnome/desktop/remote-access/enabled':            "false",
          '/org/gnome/desktop/remote-access/icon-visibility':    "'client'",
          '/org/gnome/desktop/remote-access/network-interface':  "''",
          '/org/gnome/desktop/remote-access/notify-on-connect':  "true",
          '/org/gnome/desktop/remote-access/prompt-enabled':     "true",
          '/org/gnome/desktop/remote-access/require-encryption': "true",
          '/org/gnome/desktop/remote-access/view-only':          "true",
        }

        self.set_dconf_values(dconf_values)


    def disable_ssh_remote_access(self):
        self.call_puavo_admin_remote_connections([ '--reject-incoming' ])


    def call_puavo_admin_remote_connections(self, cmdargs):
        cmdpath = '/usr/lib/puavo-ltsp-client/puavo-admin-remote-connections'
        return subprocess.check_output([ cmdpath ] + cmdargs)


    def set_dconf_values(self, dconf_values):
        for key, value in dconf_values.iteritems():
            subprocess.check_call([ 'dconf', 'write', key, value ])



class RemoteAssistanceApplet:
    def __init__(self, access_handler, conffile_path):
        self.access_handler = access_handler
        self.conffile_path  = conffile_path

        self.indicator \
            = appindicator.Indicator('remote-assistance',
                                     'vendor_favicon',
                                     appindicator.CATEGORY_COMMUNICATIONS)

        self.indicator.set_status(appindicator.STATUS_ACTIVE)

        menu = gtk.Menu()

        if self.access_handler.check_gnome_remote_access_is_allowed():
            print("Gnome remote access is allowed")
        else:
            print("Gnome remote access is *NOT* allowed")

        if self.access_handler.check_ssh_remote_access_is_allowed():
            print("Ssh remote access is allowed")
        else:
            print("Ssh remote access is *NOT* allowed")

        # XXX translations
        enable_access_button = gtk.MenuItem('Enable remote access')
        enable_access_button.connect('activate',
                                     self.access_handler.enable_remote_access)
        enable_access_button.show()
        menu.append(enable_access_button)

        # XXX translations
        disable_access_button = gtk.MenuItem('Disable remote access')
        disable_access_button.connect('activate',
                                      self.access_handler.disable_remote_access)
        disable_access_button.show()
        menu.append(disable_access_button)

        # XXX translations
        close_button = gtk.MenuItem('Close')
        close_button.connect('activate', self.close)
        close_button.show()
        menu.append(close_button)

        self.indicator.set_menu(menu)


    def close(self, widget):
        try:
            os.remove(self.conffile_path)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise e

        sys.exit(0)


autostart = False

access_handler = RemoteAccessHandler()

for arg in sys.argv[1:]:
    if arg == '--autostart':
        autostart = True
    elif arg == '--enable':
        access_handler.enable_remote_access()
    elif arg == '--disable':
        access_handler.disable_remote_access()
    else:
        print('Unknown argument: %s' % arg, file=sys.stderr)
        sys.exit(1)


# This conffile is basically just autostarting control, but may take other
# roles later (in which case the autostart information should be contained
# in this file).  No point in changing to a new path later if functionality
# changes...
user_puavo_dir = os.path.join(os.environ['HOME'], '.puavo')
conffile_path = os.path.join(user_puavo_dir,
                             'puavo-remote-assistance-applet.conf')

# Do not start the applet if autostarting and conffile does not exist.
# Note that --enable and --disable may have had an effect already.
if autostart and not os.path.exists(conffile_path):
    sys.exit(0)

try:
    os.mkdir(user_puavo_dir)
except OSError, e:
    if e.errno != errno.EEXIST:
        raise e

# touch the conffile_path, making --autostart start the applet later
conffile = open(conffile_path, 'w+')

# if this fails, this applet is likely running and we should just fail here
fcntl.flock(conffile,
            fcntl.LOCK_EX | fcntl.LOCK_NB)

applet = RemoteAssistanceApplet(access_handler, conffile_path)
gtk.main()

conffile.close()
